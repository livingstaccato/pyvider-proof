warning: `VIRTUAL_ENV=/Users/tim/code/pyvider/.venv` does not match the project environment path `.venv` and will be ignored; use `--active` to target the active environment instead
============================= test session starts ==============================
platform darwin -- Python 3.13.2, pytest-8.3.5, pluggy-1.5.0
rootdir: /Users/tim/code/pyvider-cty
configfile: pyproject.toml
testpaths: tests
plugins: cov-6.0.0, asyncio-0.25.3, anyio-4.8.0, typeguard-2.13.3, xdist-3.6.1
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=function
created: 24/24 workers
24 workers [455 items]

scheduling tests via LoadScheduling

tests/conversions/test_convert.py::TestConversionSystem::test_primitive_conversions 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_register_unsafe_conversion 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_dynamic 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_map 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_value_error 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_string_value 
tests/conversions/test_convert.py::TestConversionSystem::test_unification 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_find_no_path 
[gw5] [  0%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_find_no_path 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_convert 
tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_unsafe_function 
tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_known_value 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_null_data 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_string 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_get_unsafe_conversion 
[gw4] [  0%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_get_unsafe_conversion 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_get_identity_conversion 
[gw4] [  0%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_get_identity_conversion 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_find_direct_path 
[gw4] [  0%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_find_direct_path 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_no_conversion 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_type 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_number_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_marked_value 
tests/conversions/test_convert_2.py::TestBuiltinConversions::test_identity_conversion 
[gw8] [  1%] PASSED tests/conversions/test_convert_2.py::TestBuiltinConversions::test_identity_conversion 
tests/conversions/test_convert_base.py::TestConversion::test_conversion_init 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_unknown_value 
tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_with_marks 
tests/conversions/test_convert_2.py::TestConversion::test_conversion_convert_failure 
[gw3] [  1%] PASSED tests/conversions/test_convert_2.py::TestConversion::test_conversion_convert_failure 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_register 
tests/conversions/test_convert_2.py::TestConvertFunctions::test_convert_function 
[gw22] [  1%] PASSED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_value_error 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_decode_roundtrip_string 
tests/conversions/test_convert.py::TestConversionSystem::test_integration_with_operations 
[gw3] [  1%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_register 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_find_multistep_path 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_type_error 
[gw23] [  1%] PASSED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_type_error 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_type_string 
[gw23] [  2%] PASSED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_type_string 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_complex_type 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_register_unsafe_only 
[gw4] [  2%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_find_multistep_path 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_marshal_unmarshal_roundtrip 
[gw3] [  2%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_register_unsafe_only 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_get_safe_conversion 
[gw3] [  2%] PASSED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_get_safe_conversion 
tests/functions/test_function_base.py::TestFunctionSystem::test_function_registry 
[gw10] [  3%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_no_conversion 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_unsafe_with_unsafe_conversion 
[gw13] [  3%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_unknown_value 
[gw11] [  3%] FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_known_value 
tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_unknown_value 
[gw12] [  3%] FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_with_marks 
tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_register_conversion_call 
[gw9] [  3%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_register_unsafe_conversion 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_null_value 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_get_nonexistent_conversion 
[gw1] [  4%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_unification 
tests/conversions/test_convert.py::TestConversionSystem::test_custom_conversion 
[gw10] [  4%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_unsafe_with_unsafe_conversion 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_unsafe_no_conversion 
[gw9] [  4%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_get_nonexistent_conversion 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_same_type 
[gw8] [  4%] FAILED tests/conversions/test_convert_base.py::TestConversion::test_conversion_init 
tests/conversions/test_convert_base.py::TestConversion::test_conversion_convert 
[gw8] [  5%] FAILED tests/conversions/test_convert_base.py::TestConversion::test_conversion_convert 
[gw1] [  5%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_custom_conversion 
[gw15] [  5%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_map 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_set 
[gw13] [  5%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_null_value 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_string_data 
[gw11] [  5%] FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_unknown_value 
tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_null_value 
[gw11] [  6%] FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_null_value 
tests/conversions/test_convert.py::TestConversionSystem::test_conversion_path_finding 
[gw10] [  6%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_unsafe_no_conversion 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_multiple_conversions 
[gw10] [  6%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_multiple_conversions 
tests/list/test_cty_collections_list.py::test_CtyList_validate_failure 
[gw10] [  6%] PASSED tests/list/test_cty_collections_list.py::test_CtyList_validate_failure 
tests/list/test_cty_collections_list.py::test_CtyList_validate_nested_lists 
[gw10] [  7%] FAILED tests/list/test_cty_collections_list.py::test_CtyList_validate_nested_lists 
tests/list/test_cty_collections_list.py::test_CtyList_validate_empty_list 
[gw18] [  7%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_type 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_marshal_unmarshal_roundtrip 
tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_invalid_string 
[gw10] [  7%] PASSED tests/list/test_cty_collections_list.py::test_CtyList_validate_empty_list 
tests/list/test_cty_collections_list.py::test_CtyList_validate_none 
[gw17] [  7%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_dynamic 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_null_values 
[gw4] [  7%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_marshal_unmarshal_roundtrip 
tests/functions/test_function_base.py::TestFunctionSystem::test_parameter_validation 
[gw3] [  8%] FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_function_registry 
tests/functions/test_function_base.py::TestFunctionSystem::test_integration_with_values 
[gw0] [  8%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_primitive_conversions 
tests/conversions/test_convert.py::TestConversionSystem::test_invalid_conversions 
[gw0] [  8%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_invalid_conversions 
[gw1] [  8%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_conversion_path_finding 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_register_safe_conversion 
[gw8] [  9%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_register_safe_conversion 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_tuple_as_list 
[gw8] [  9%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_tuple_as_list 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_none_becomes_empty_list 
[gw10] [  9%] PASSED tests/list/test_cty_collections_list.py::test_CtyList_validate_none 
[gw20] [  9%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_marked_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_list_value 
tests/list/test_cty_collections_list.py::test_CtyList_invalid_element_type 
[gw8] [  9%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_none_becomes_empty_list 
[gw9] [ 10%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_same_type 
tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_with_conversion 
[gw9] [ 10%] FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_with_conversion 
tests/list/test_cty_collections_list.py::test_CtyList_invalid_structure 
[gw9] [ 10%] PASSED tests/list/test_cty_collections_list.py::test_CtyList_invalid_structure 
tests/list/test_cty_collections_list.py::test_CtyList_validate_none_in_list 
[gw9] [ 10%] PASSED tests/list/test_cty_collections_list.py::test_CtyList_validate_none_in_list 
tests/list/test_cty_collections_list.py::test_CtyList_large_list 
[gw9] [ 10%] PASSED tests/list/test_cty_collections_list.py::test_CtyList_large_list 
tests/list/test_cty_collections_list.py::test_CtyList_dynamic_schema 
[gw9] [ 11%] FAILED tests/list/test_cty_collections_list.py::test_CtyList_dynamic_schema 
[gw2] [ 11%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_integration_with_operations 
tests/conversions/test_convert.py::TestConversionSystem::test_integration_with_functions 
[gw23] [ 11%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_complex_type 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_type_error 
[gw23] [ 11%] PASSED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_type_error 
tests/functions/test_stdlib.py::TestStdlibFunctions::test_conversion_functions 
[gw23] [ 12%] FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_conversion_functions 
tests/conversions/test_convert.py::TestConversionSystem::test_collection_type_handling 
[gw3] [ 12%] FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_integration_with_values 
tests/functions/test_stdlib.py::TestStdlibFunctions::test_string_functions 
[gw18] [ 12%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_marshal_unmarshal_roundtrip 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_error_handling 
[gw22] [ 12%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_decode_roundtrip_string 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_type 
[gw22] [ 12%] PASSED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_type 
[gw21] [ 13%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_string_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_number_value 
[gw4] [ 13%] FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_parameter_validation 
[gw15] [ 13%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_set 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_object 
[gw15] [ 13%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_object 
tests/functions/test_function_base.py::TestFunctionSystem::test_variadic_parameter 
[gw11] [ 14%] FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_invalid_string 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_negative_index 
[gw11] [ 14%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_negative_index 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_invalid_container 
[gw11] [ 14%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_invalid_container 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_same_element_type 
tests/conversions/test_convert.py::TestConversionSystem::test_null_and_unknown_handling 
[gw0] [ 14%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_null_and_unknown_handling 
[gw3] [ 14%] FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_string_functions 
tests/functions/test_stdlib.py::TestStdlibFunctions::test_numeric_functions 
[gw14] [ 15%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_null_data 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_invalid_json 
[gw14] [ 15%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_invalid_json 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_complex_value 
[gw14] [ 15%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_complex_value 
[gw2] [ 15%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_integration_with_functions 
tests/conversions/test_convert_2.py::TestConversion::test_conversion_init 
[gw2] [ 16%] PASSED tests/conversions/test_convert_2.py::TestConversion::test_conversion_init 
[gw12] [ 16%] FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_register_conversion_call 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_known_value 
[gw12] [ 16%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_known_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_complex_type 
[gw11] [ 16%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_same_element_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_different_element_type 
[gw10] [ 16%] PASSED tests/list/test_cty_collections_list.py::test_CtyList_invalid_element_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_string_representation 
[gw10] [ 17%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_string_representation 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_string_representation_complex 
[gw10] [ 17%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_string_representation_complex 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_list_equality_operator 
[gw10] [ 17%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_list_equality_operator 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_post_init_validates_element_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_invalid_container_type 
[gw8] [ 17%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_invalid_container_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_homogeneous_list 
[gw8] [ 18%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_homogeneous_list 
tests/functions/test_stdlib.py::TestStdlibFunctions::test_filesystem_functions 
[gw23] [ 18%] FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_filesystem_functions 
tests/functions/test_stdlib.py::TestStdlibFunctions::test_crypto_functions 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_tuple 
[gw18] [ 18%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_error_handling 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_string_value 
[gw20] [ 18%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_list_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_map_value 
[gw20] [ 18%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_map_value 
[gw6] [ 19%] FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_convert_function 
tests/conversions/test_convert_2.py::TestConvertFunctions::test_convert_unsafe_function 
[gw19] [ 19%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_number_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_bool_value 
[gw19] [ 19%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_bool_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_unknown_value 
[gw13] [ 19%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_string_data 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_bytes_data 
[gw13] [ 20%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_bytes_data 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_nested_lists 
[gw13] [ 20%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_nested_lists 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_nested_list_with_errors 
[gw15] [ 20%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_tuple 
[gw1] [ 20%] FAILED tests/conversions/test_convert.py::TestConversionSystem::test_collection_type_handling 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_non_list_type 
[gw1] [ 20%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_non_list_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_same_type 
[gw1] [ 21%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_same_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_different_type 
[gw1] [ 21%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_different_type 
[gw11] [ 21%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_different_element_type 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_string_representation_complex 
[gw11] [ 21%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_string_representation_complex 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_different_type 
[gw7] [ 21%] FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_unsafe_function 
tests/conversions/test_convert_2.py::TestConvertFunctions::test_unify_function 
[gw23] [ 22%] FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_crypto_functions 
tests/functions/test_stdlib.py::TestStdlibFunctions::test_null_and_unknown_handling 
[gw9] [ 22%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_post_init_validates_element_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_repr_representation 
[gw9] [ 22%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_repr_representation 
tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_tuples 
[gw9] [ 22%] PASSED tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_tuples 
tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_tuples_invalid 
[gw9] [ 23%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_tuples_invalid 
[gw21] [ 23%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_number_value 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_with_ext_hook_unknown 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_list_inequality_operator 
[gw15] [ 23%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_list_inequality_operator 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_post_init_validates_element_type 
[gw15] [ 23%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_post_init_validates_element_type 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_repr_representation 
[gw15] [ 23%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_repr_representation 
[gw17] [ 24%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_null_values 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_unknown_values 
[gw17] [ 24%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_unknown_values 
[gw13] [ 24%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_nested_list_with_errors 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_valid_index 
[gw11] [ 24%] FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_different_type 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_non_list_type 
[gw11] [ 25%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_non_list_type 
[gw4] [ 25%] FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_variadic_parameter 
tests/functions/test_function_base.py::TestFunctionSystem::test_function_spec 
[gw4] [ 25%] FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_function_spec 
[gw3] [ 25%] FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_numeric_functions 
[gw16] [ 25%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_string 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_number 
[gw16] [ 26%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_number 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_bool 
[gw16] [ 26%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_bool 
[gw19] [ 26%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_unknown_value 
[gw21] [ 26%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_with_ext_hook_unknown 
[gw13] [ 27%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_valid_index 
[gw22] [ 27%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_complex_type 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_valid_index 
[gw22] [ 27%] FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_valid_index 
[gw23] [ 27%] FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_null_and_unknown_handling 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_equal_different_element_type 
[gw22] [ 27%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_equal_different_element_type 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_equal_non_list_type 
[gw22] [ 28%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_equal_non_list_type 
[gw18] [ 28%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_string_value 
tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_empty_list_elements 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_equal_same_element_type 
[gw22] [ 28%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_equal_same_element_type 
tests/conversions/test_convert.py::TestConversionSystem::test_can_convert 
[gw18] [ 28%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_empty_list_elements 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_invalid_container 
[gw18] [ 29%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_invalid_container 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_invalid_index 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_with_type 
tests/functions/test_stdlib.py::TestStdlibFunctions::test_collection_functions 
tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_complex_data 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_list_inequality_operator 
[gw18] [ 29%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_invalid_index 
[gw0] [ 29%] PASSED tests/conversions/test_convert.py::TestConversionSystem::test_can_convert 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_heterogeneous_list_fails 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_heterogeneous_list_fails 
[gw5] [ 29%] FAILED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_convert 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_convert_no_path 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_value_error 
[gw20] [ 29%] PASSED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_value_error 
tests/object/test_cty_structural_object.py::test_ctyobject_equal_different_attribute_types 
[gw12] [ 30%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_with_type 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_non_list_type 
tests/conversions/test_convert_2.py::TestConversion::test_conversion_convert_success 
[gw2] [ 30%] PASSED tests/conversions/test_convert_2.py::TestConversion::test_conversion_convert_success 
tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_mixed_depth_list 
[gw2] [ 30%] PASSED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_mixed_depth_list 
tests/object/test_cty_structural_object.py::test_ctyobject_validate_success 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_same_type 
[gw14] [ 30%] FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_complex_data 
tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_empty_list_elements 
[gw14] [ 30%] FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_empty_list_elements 
tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_lists_of_strings 
[gw14] [ 31%] FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_lists_of_strings 
tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_tuples 
tests/functions/test_function_base.py::TestFunctionSystem::test_function_callable 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_marked_values 
[gw1] [ 31%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_non_list_type 
tests/object/test_cty_structural_object.py::test_ctyobject_usable_as_required_attributes 
[gw1] [ 31%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_usable_as_required_attributes 
tests/object/test_cty_structural_object.py::test_ctyobject_with_optional_attributes_method 
[gw1] [ 31%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_with_optional_attributes_method 
tests/object/test_cty_structural_object.py::test_ctyobject_with_computed_attributes_method 
[gw1] [ 32%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_with_computed_attributes_method 
tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_lists_of_strings 
[gw9] [ 32%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_lists_of_strings 
tests/object/test_cty_structural_object.py::test_ctyobject_with_sensitive_attributes_method 
[gw9] [ 32%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_with_sensitive_attributes_method 
tests/object/test_cty_structural_object.py::test_ctyobject_with_attribute_method 
[gw9] [ 32%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_with_attribute_method 
tests/object/test_cty_structural_object.py::test_ctyobject_with_attribute_already_exists 
[gw14] [ 32%] FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_tuples 
tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_invalid_index 
[gw13] [ 33%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_invalid_index 
tests/object/test_object.py::TestCtyObjectIntegration::test_with_block_attributes 
[gw13] [ 33%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_with_block_attributes 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_list_equality_operator 
[gw22] [ 33%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_list_equality_operator 
tests/object/test_object.py::TestCtyObjectIntegration::test_equal_different_optional 
[gw22] [ 33%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_equal_different_optional 
tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_same_type 
[gw22] [ 34%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_same_type 
[gw11] [ 34%] FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_same_type 
tests/object/test_object.py::TestCtyObjectIntegration::test_basic_object_creation 
[gw11] [ 34%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_basic_object_creation 
tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_optional_attributes 
[gw11] [ 34%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_optional_attributes 
tests/list/test_cty_collections_list.py::test_CtyList_validate_success 
[gw23] [ 34%] FAILED tests/list/test_cty_collections_list.py::test_CtyList_validate_success 
tests/object/test_object.py::TestCtyObjectIntegration::test_equal_same_type 
[gw23] [ 35%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_equal_same_type 
[gw10] [ 35%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_list_inequality_operator 
tests/object/test_cty_structural_object.py::test_ctyobject_get_valid_attribute 
[gw10] [ 35%] FAILED tests/object/test_cty_structural_object.py::test_ctyobject_get_valid_attribute 
tests/object/test_cty_structural_object.py::test_ctyobject_get_invalid_attribute 
[gw10] [ 35%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_get_invalid_attribute 
tests/object/test_cty_structural_object.py::test_ctyobject_has_attribute 
[gw10] [ 36%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_has_attribute 
[gw3] [ 36%] FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_collection_functions 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_nested_lists 
[gw3] [ 36%] FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_nested_lists 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_none_becomes_empty_list 
[gw3] [ 36%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_none_becomes_empty_list 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_tuple_as_list 
[gw3] [ 36%] FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_tuple_as_list 
[gw20] [ 37%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_equal_different_attribute_types 
tests/object/test_cty_structural_object.py::test_ctyobject_equal_different_optional 
[gw20] [ 37%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_equal_different_optional 
tests/object/test_cty_structural_object.py::test_ctyobject_usable_as_same_type 
[gw20] [ 37%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_usable_as_same_type 
[gw0] [ 37%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_heterogeneous_list_fails 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_homogeneous_list 
[gw0] [ 38%] FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_homogeneous_list 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_invalid_container_type 
[gw0] [ 38%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_invalid_container_type 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_null_value 
[gw17] [ 38%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_marked_values 
tests/object/test_cty_structural_object.py::test_ctyobject_validate_with_extra_attributes 
[gw17] [ 38%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_validate_with_extra_attributes 
tests/object/test_cty_structural_object.py::test_ctyobject_cascading_validation_error 
[gw17] [ 38%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_cascading_validation_error 
tests/object/test_cty_structural_object.py::test_ctyobject_validation_performance_large_object 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_negative_index 
[gw18] [ 39%] FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_negative_index 
tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_compatible_types 
[gw18] [ 39%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_compatible_types 
tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_required_attributes 
[gw18] [ 39%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_required_attributes 
tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_computed_attributes 
[gw11] [ 39%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_computed_attributes 
tests/object/test_object.py::TestCtyObjectIntegration::test_equal_different_attributes 
[gw23] [ 40%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_equal_different_attributes 
[gw9] [ 40%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_with_attribute_already_exists 
[gw4] [ 40%] FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_function_callable 
tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_sensitive_attributes 
[gw4] [ 40%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_sensitive_attributes 
tests/object/test_object.py::TestCtyObjectIntegration::test_validation_success 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_string_representation 
[gw15] [ 40%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_string_representation 
tests/object/test_cty_structural_object.py::test_ctyobject_validate_not_dict 
[gw15] [ 41%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_validate_not_dict 
tests/object/test_cty_structural_object.py::test_ctyobject_to_string 
[gw15] [ 41%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_to_string 
tests/object/test_cty_structural_object.py::test_create_object_helper 
[gw15] [ 41%] FAILED tests/object/test_cty_structural_object.py::test_create_object_helper 
[gw8] [ 41%] FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_heterogeneous_list_fails 
tests/object/test_cty_structural_object.py::test_ctyobject_invalid_block 
[gw8] [ 41%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_invalid_block 
tests/object/test_cty_structural_object.py::test_ctyobject_equality 
[gw8] [ 42%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_equality 
tests/object/test_cty_structural_object.py::test_ctyobject_inequality 
[gw8] [ 42%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_inequality 
tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_list 
[gw16] [ 42%] FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_list 
tests/object/test_object.py::TestCtyObjectIntegration::test_validation_failure_missing_required 
[gw16] [ 42%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_failure_missing_required 
tests/object/test_object.py::TestCtyObjectIntegration::test_validation_failure_wrong_type 
[gw16] [ 43%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_failure_wrong_type 
tests/object/test_cty_structural_object.py::test_ctyobject_with_block_attributes_method 
[gw1] [ 43%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_with_block_attributes_method 
tests/object/test_object.py::TestCtyObjectIntegration::test_complex_nested_object 
tests/object/test_cty_structural_object.py::test_ctyobject_nested_validation 
[gw12] [ 43%] FAILED tests/object/test_cty_structural_object.py::test_ctyobject_nested_validation 
tests/object/test_cty_structural_object.py::test_ctyobject_nested_invalid_type 
[gw12] [ 43%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_nested_invalid_type 
tests/object/test_cty_structural_object.py::test_ctyobject_optional_attributes 
[gw12] [ 43%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_optional_attributes 
tests/object/test_object.py::TestCtyObjectIntegration::test_with_sensitive_attributes 
[gw13] [ 44%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_with_sensitive_attributes 
[gw17] [ 44%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_validation_performance_large_object 
[gw2] [ 44%] FAILED tests/object/test_cty_structural_object.py::test_ctyobject_validate_success 
tests/object/test_cty_structural_object.py::test_ctyobject_validate_missing_required 
[gw2] [ 44%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_validate_missing_required 
tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_tuples_invalid 
tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_with_ext_hook_null 
[gw21] [ 45%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_with_ext_hook_null 
tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_subset_attributes 
[gw22] [ 45%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_usable_as_subset_attributes 
tests/path/test_cty_path.py::TestPath::test_path_child 
[gw19] [ 45%] FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_null_value 
tests/object/test_object.py::TestCtyObjectIntegration::test_get_attribute 
[gw19] [ 45%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_get_attribute 
tests/object/test_object.py::TestCtyObjectIntegration::test_get_attribute_unknown 
[gw19] [ 45%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_get_attribute_unknown 
tests/object/test_cty_structural_object.py::test_ctyobject_with_blocks 
[gw4] [ 46%] FAILED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_success 
tests/object/test_object.py::TestCtyObjectIntegration::test_validation_with_optional_attributes 
[gw14] [ 46%] PASSED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_tuples_invalid 
tests/path/test_cty_path.py::TestGetAttrStep::test_get_attr_step_init 
[gw14] [ 46%] PASSED tests/path/test_cty_path.py::TestGetAttrStep::test_get_attr_step_init 
tests/path/test_cty_path.py::TestPath::test_path_init_empty 
[gw14] [ 46%] PASSED tests/path/test_cty_path.py::TestPath::test_path_init_empty 
tests/object/test_object.py::TestCtyObjectIntegration::test_with_optional_attributes 
[gw21] [ 47%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_with_optional_attributes 
tests/object/test_object.py::TestCtyObjectIntegration::test_with_required_attributes 
[gw21] [ 47%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_with_required_attributes 
tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_nested_list_with_errors 
[gw0] [ 47%] PASSED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_nested_list_with_errors 
tests/path/test_path.py::TestPathSystem::test_key_paths 
[gw1] [ 47%] FAILED tests/object/test_object.py::TestCtyObjectIntegration::test_complex_nested_object 
tests/object/test_object.py::TestCtyObjectIntegration::test_validation_performance_large_object 
tests/object/test_object.py::TestCtyObjectIntegration::test_equal_different_attribute_types 
[gw23] [ 47%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_equal_different_attribute_types 
tests/path/test_path_path_advanced.py::TestRefinement::test_not_null_builder 
[gw23] [ 48%] PASSED tests/path/test_path_path_advanced.py::TestRefinement::test_not_null_builder 
tests/object/test_cty_structural_object.py::test_ctyobject_usable_as_subset_attributes 
[gw20] [ 48%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_usable_as_subset_attributes 
tests/path/test_cty_path.py::TestPath::test_path_class_methods[<lambda>-expected1] 
[gw20] [ 48%] PASSED tests/path/test_cty_path.py::TestPath::test_path_class_methods[<lambda>-expected1] 
tests/path/test_path.py::TestPathSystem::test_attribute_paths 
tests/object/test_object.py::TestCtyObjectIntegration::test_create_object_helper 
[gw18] [ 48%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_create_object_helper 
tests/path/test_path.py::TestPathSystem::test_path_string_representation 
[gw18] [ 49%] PASSED tests/path/test_path.py::TestPathSystem::test_path_string_representation 
tests/path/test_path_path_advanced.py::TestRefinement::test_not_null_refinement 
[gw18] [ 49%] PASSED tests/path/test_path_path_advanced.py::TestRefinement::test_not_null_refinement 
tests/object/test_object.py::TestCtyObjectIntegration::test_with_attribute 
[gw22] [ 49%] PASSED tests/path/test_cty_path.py::TestPath::test_path_child 
tests/path/test_cty_path.py::TestPath::test_path_child_chaining 
[gw22] [ 49%] PASSED tests/path/test_cty_path.py::TestPath::test_path_child_chaining 
tests/object/test_cty_structural_object.py::test_ctyobject_equality_with_different_attributes 
[gw8] [ 49%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_equality_with_different_attributes 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init 
tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_block_attributes 
[gw11] [ 50%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_object_with_block_attributes 
tests/path/test_path_path_advanced.py::TestRefinement::test_number_range_refinement 
[gw11] [ 50%] PASSED tests/path/test_path_path_advanced.py::TestRefinement::test_number_range_refinement 
tests/object/test_cty_structural_object.py::test_ctyobject_with_invalid_block_attributes 
[gw12] [ 50%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_with_invalid_block_attributes 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_validate_with_validators 
[gw6] [ 50%] FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_convert_unsafe_function 
tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_function 
[gw4] [ 50%] FAILED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_with_optional_attributes 
[gw0] [ 51%] FAILED tests/path/test_path.py::TestPathSystem::test_key_paths 
[gw7] [ 51%] FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_unify_function 
tests/conversions/test_convert_2.py::TestConvertFunctions::test_unify_unsafe_function 
tests/object/test_object.py::TestCtyObjectIntegration::test_has_attribute 
[gw19] [ 51%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_has_attribute 
tests/object/test_cty_structural_object.py::test_ctyobject_invalid_constructor_types 
[gw9] [ 51%] FAILED tests/object/test_cty_structural_object.py::test_ctyobject_invalid_constructor_types 
tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_usable_as 
[gw9] [ 52%] PASSED tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_usable_as 
tests/object/test_object.py::TestCtyObjectIntegration::test_validation_failure_not_dict 
[gw16] [ 52%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_failure_not_dict 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init_with_validators 
[gw16] [ 52%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init_with_validators 
tests/object/test_cty_structural_object.py::test_ctyobject_validate_null 
[gw2] [ 52%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_validate_null 
tests/types/test_cty_types_simple.py::TestCtyNumberType::test_validate_invalid_number 
[gw2] [ 52%] PASSED tests/types/test_cty_types_simple.py::TestCtyNumberType::test_validate_invalid_number 
tests/object/test_cty_structural_object.py::test_complex_nested_object 
[gw20] [ 53%] FAILED tests/path/test_path.py::TestPathSystem::test_attribute_paths 
[gw10] [ 53%] FAILED tests/object/test_cty_structural_object.py::test_ctyobject_with_blocks 
tests/path/test_cty_path.py::TestPath::test_path_key_step 
[gw10] [ 53%] PASSED tests/path/test_cty_path.py::TestPath::test_path_key_step 
tests/path/test_cty_path.py::TestPath::test_path_apply_path_empty 
[gw10] [ 53%] PASSED tests/path/test_cty_path.py::TestPath::test_path_apply_path_empty 
[gw12] [ 54%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_validate_with_validators 
tests/types/test_cty_types_simple.py::TestCtyBoolType::test_validate_invalid_bool 
[gw19] [ 54%] PASSED tests/types/test_cty_types_simple.py::TestCtyBoolType::test_validate_invalid_bool 
[gw1] [ 54%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_performance_large_object 
tests/object/test_object.py::TestCtyObjectIntegration::test_with_computed_attributes 
[gw21] [ 54%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_with_computed_attributes 
tests/values/test_values_base.py::TestValue::test_value_has_mark 
[gw21] [ 54%] PASSED tests/values/test_values_base.py::TestValue::test_value_has_mark 
tests/path/test_path_path_advanced.py::TestRefinement::test_string_prefix_refinement 
[gw18] [ 55%] PASSED tests/path/test_path_path_advanced.py::TestRefinement::test_string_prefix_refinement 
tests/values/test_values_base.py::TestValue::test_value_null 
[gw18] [ 55%] PASSED tests/values/test_values_base.py::TestValue::test_value_null 
tests/object/test_cty_structural_object.py::test_ctyobject_get_attribute_from_non_dict 
[gw15] [ 55%] PASSED tests/object/test_cty_structural_object.py::test_ctyobject_get_attribute_from_non_dict 
tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_validate_valid_tuple 
[gw15] [ 55%] PASSED tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_validate_valid_tuple 
tests/path/test_cty_path.py::TestPath::test_path_init_with_steps 
[gw14] [ 56%] PASSED tests/path/test_cty_path.py::TestPath::test_path_init_with_steps 
tests/values/test_values_base.py::TestValue::test_value_add_mark 
tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_equal 
[gw23] [ 56%] PASSED tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_equal 
tests/values/test_values_base.py::TestValue::test_value_is_known_property 
[gw23] [ 56%] PASSED tests/values/test_values_base.py::TestValue::test_value_is_known_property 
tests/path/test_path.py::TestPathSystem::test_complex_paths 
tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_complex_nesting 
[gw17] [ 56%] FAILED tests/object/test_cty_structural_object.py::test_complex_nested_object 
tests/types/test_cty_types_simple.py::TestCtyStringType::test_validate_invalid_string 
[gw17] [ 56%] PASSED tests/types/test_cty_types_simple.py::TestCtyStringType::test_validate_invalid_string 
[gw13] [ 57%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_with_attribute 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_usable_as 
[gw13] [ 57%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_usable_as 
[gw3] [ 57%] FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_complex_nesting 
tests/path/test_cty_path.py::TestPath::test_path_string_with_steps 
[gw3] [ 57%] PASSED tests/path/test_cty_path.py::TestPath::test_path_string_with_steps 
tests/path/test_cty_path.py::TestPath::test_path_str_dunder 
[gw3] [ 58%] PASSED tests/path/test_cty_path.py::TestPath::test_path_str_dunder 
[gw8] [ 58%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init 
[gw14] [ 58%] FAILED tests/values/test_values_base.py::TestValue::test_value_add_mark 
tests/path/test_cty_path.py::TestPath::test_path_index_step 
tests/path/test_path_path_advanced.py::TestRefinement::test_refinement_builder 
tests/object/test_object.py::TestCtyObjectIntegration::test_validation_with_null_value 
[gw0] [ 58%] FAILED tests/path/test_path.py::TestPathSystem::test_complex_paths 
[gw22] [ 58%] PASSED tests/path/test_cty_path.py::TestPath::test_path_index_step 
[gw4] [ 59%] PASSED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_with_null_value 
tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_validate_invalid_tuple 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_validate 
[gw11] [ 59%] PASSED tests/path/test_path_path_advanced.py::TestRefinement::test_refinement_builder 
tests/values/test_values_base.py::TestValue::test_value_unmark 
tests/types/test_cty_types_simple.py::TestCtyNumberType::test_validate_valid_number 
tests/values/test_values_base.py::TestValue::test_value_type_property 
[gw9] [ 59%] PASSED tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_validate_invalid_tuple 
tests/values/test_values_operations.py::test_equals_null_unknown 
tests/path/test_path.py::TestPathSystem::test_index_paths 
[gw2] [ 59%] PASSED tests/types/test_cty_types_simple.py::TestCtyNumberType::test_validate_valid_number 
tests/values/test_values_operations.py::test_add_strings 
[gw22] [ 60%] PASSED tests/values/test_values_base.py::TestValue::test_value_type_property 
tests/values/test_values_operations.py::test_equals_basic 
tests/path/test_cty_path.py::TestPath::test_path_string_empty 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_equal 
tests/types/test_cty_types_simple.py::TestCtyBoolType::test_validate_valid_bool 
[gw19] [ 60%] PASSED tests/types/test_cty_types_simple.py::TestCtyBoolType::test_validate_valid_bool 
[gw4] [ 60%] PASSED tests/values/test_values_operations.py::test_equals_basic 
[gw5] [ 60%] FAILED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_convert_no_path 
[gw11] [ 60%] FAILED tests/values/test_values_base.py::TestValue::test_value_unmark 
[gw16] [ 61%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_validate 
tests/values/test_values_operations.py::test_add_null_unknown 
[gw16] [ 61%] PASSED tests/values/test_values_operations.py::test_add_null_unknown 
[gw9] [ 61%] PASSED tests/values/test_values_operations.py::test_equals_null_unknown 
[gw10] [ 61%] PASSED tests/path/test_cty_path.py::TestPath::test_path_string_empty 
tests/values/test_values_operations.py::test_divide 
tests/path/test_cty_path.py::TestPathStep::test_path_step_is_abstract 
[gw1] [ 61%] PASSED tests/path/test_cty_path.py::TestPathStep::test_path_step_is_abstract 
[gw2] [ 62%] PASSED tests/values/test_values_operations.py::test_add_strings 
tests/values/test_values_base.py::TestValue::test_value_initialization 
[gw21] [ 62%] PASSED tests/values/test_values_base.py::TestValue::test_value_initialization 
tests/values/test_values_base.py::TestValue::test_value_is_null_property 
[gw23] [ 62%] PASSED tests/values/test_values_base.py::TestValue::test_value_is_null_property 
tests/values/test_values_base.py::TestValue::test_value_refine 
[gw18] [ 62%] PASSED tests/values/test_values_base.py::TestValue::test_value_refine 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_string_representation 
[gw12] [ 63%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_equal 
tests/values/test_values_operations.py::test_negate 
[gw12] [ 63%] PASSED tests/values/test_values_operations.py::test_negate 
tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_validate_wrong_length 
[gw15] [ 63%] PASSED tests/tuple/test_cty_structural_tuple.py::TestCtyTupleType::test_validate_wrong_length 
tests/types/test_cty_types_simple.py::TestCtyStringType::test_validate_valid_string 
[gw17] [ 63%] PASSED tests/types/test_cty_types_simple.py::TestCtyStringType::test_validate_valid_string 
tests/path/test_cty_path.py::TestPath::test_path_class_methods[<lambda>-expected0] 
tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init_with_metadata 
tests/values/test_values_base.py::TestValue::test_value_add_multiple_marks 
tests/path/test_path.py::TestPathSystem::test_null_and_unknown_handling 
[gw13] [ 63%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_string_representation 
[gw3] [ 64%] PASSED tests/path/test_cty_path.py::TestPath::test_path_class_methods[<lambda>-expected0] 
tests/values/test_values_operations.py::test_equals_complex 
tests/values/test_values_operations.py::test_get_element 
[gw20] [ 64%] FAILED tests/path/test_path.py::TestPathSystem::test_index_paths 
tests/values/test_values_operations.py::test_subtract 
tests/values/test_values_base.py::TestValue::test_value_unknown 
tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_unify 
[gw8] [ 64%] FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init_with_metadata 
[gw22] [ 64%] PASSED tests/values/test_values_base.py::TestValue::test_value_unknown 
tests/values/test_values_base.py::TestValue::test_value_with_marks 
[gw11] [ 65%] PASSED tests/values/test_values_base.py::TestValue::test_value_with_marks 
[gw20] [ 65%] PASSED tests/values/test_values_operations.py::test_subtract 
tests/values/test_values_operations.py::test_add_numbers 
[gw9] [ 65%] PASSED tests/values/test_values_operations.py::test_add_numbers 
tests/values/test_values_operations.py::test_length 
[gw14] [ 65%] FAILED tests/values/test_values_base.py::TestValue::test_value_add_multiple_marks 
tests/values/test_values_operations.py::test_add_lists 
tests/values/test_values_operations.py::test_contains 
tests/values/test_values_operations.py::test_add_type_errors 
tests/values/test_values_operations.py::test_concat_lists 
tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_different_values 
[gw13] [ 65%] PASSED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_different_values 
tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_different_types 
[gw18] [ 66%] PASSED tests/values/test_values_operations.py::test_concat_lists 
[gw16] [ 66%] PASSED tests/values/test_values_operations.py::test_add_type_errors 
tests/values/test_values_operations.py::test_merge_maps 
tests/values/test_values_operations.py::test_get_attribute 
[gw12] [ 66%] PASSED tests/values/test_values_operations.py::test_get_attribute 
[gw5] [ 66%] FAILED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_unify 
[gw0] [ 67%] FAILED tests/path/test_path.py::TestPathSystem::test_null_and_unknown_handling 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_incompatible_types 
[gw11] [ 67%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_incompatible_types 
tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_map_values 
tests/values/test_values_operations.py::test_multiply 
[gw20] [ 67%] PASSED tests/values/test_values_operations.py::test_multiply 
tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_unknown_values 
[gw14] [ 67%] PASSED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_unknown_values 
tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_null_values 
[gw8] [ 67%] PASSED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_null_values 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_negate_number 
[gw13] [ 68%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_negate_number 
tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_same_value 
[gw17] [ 68%] PASSED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_same_value 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_multiply_string_by_number 
[gw18] [ 68%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_multiply_string_by_number 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_lists 
[gw3] [ 68%] PASSED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_different_types 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_multiply_numbers 
[gw16] [ 69%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_multiply_numbers 
tests/values/test_values_operations.py::test_slice_string 
[gw23] [ 69%] PASSED tests/values/test_values_operations.py::test_slice_string 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_unknown_values 
[gw9] [ 69%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_unknown_values 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_modulo_numbers 
[gw12] [ 69%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_modulo_numbers 
[gw19] [ 69%] FAILED tests/values/test_values_operations.py::test_get_element 
[gw5] [ 70%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_lists 
[gw4] [ 70%] FAILED tests/values/test_values_operations.py::test_equals_complex 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_element_list 
tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_list_values 
[gw11] [ 70%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_element_list 
[gw0] [ 70%] PASSED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_list_values 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_element_out_of_bounds 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_attribute 
[gw1] [ 70%] FAILED tests/values/test_values_operations.py::test_length 
[gw8] [ 71%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_attribute 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_length_list 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_divide_by_zero 
[gw22] [ 71%] FAILED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_map_values 
[gw14] [ 71%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_element_out_of_bounds 
[gw17] [ 71%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_divide_by_zero 
[gw21] [ 72%] FAILED tests/values/test_values_operations.py::test_contains 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_length_map 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_contains_string 
[gw16] [ 72%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_contains_string 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_multiply_list_by_number 
[gw23] [ 72%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_multiply_list_by_number 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_contains_list 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_element_map 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_negate_bool 
[gw3] [ 72%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_negate_bool 
[gw13] [ 72%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_length_list 
[gw15] [ 73%] FAILED tests/values/test_values_operations.py::test_merge_maps 
[gw12] [ 73%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_contains_list 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_concat_lists 
[gw0] [ 73%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_concat_lists 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_length_string 
[gw9] [ 73%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_length_string 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_numbers 
[gw19] [ 74%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_numbers 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_contains_map_key 
[gw5] [ 74%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_contains_map_key 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_concat_lists_empty 
[gw11] [ 74%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_concat_lists_empty 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_strings 
[gw4] [ 74%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_strings 
[gw18] [ 74%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_length_map 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_attribute_missing 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_merge_maps 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_slice_string 
[gw6] [ 75%] FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_function 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_null_values 
[gw22] [ 75%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_attribute_missing 
[gw8] [ 75%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_slice_string 
[gw1] [ 75%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_add_null_values 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_unknown 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_null 
[gw3] [ 76%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_null 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_unknown 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_subtract_incompatible_types 
[gw21] [ 76%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_subtract_incompatible_types 
tests/values/test_values_operations_more.py::TestCollectionOperations::test_slice_list 
[gw13] [ 76%] PASSED tests/values/test_values_operations_more.py::TestCollectionOperations::test_slice_list 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_numbers 
[gw9] [ 76%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_numbers 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_by_zero 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_number 
[gw17] [ 76%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_number 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_invalid_types 
[gw19] [ 77%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_invalid_types 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_invalid_type 
[gw23] [ 77%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_invalid_type 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_by_zero 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo 
[gw7] [ 77%] FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_unify_unsafe_function 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_bool 
[gw18] [ 77%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_bool 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_null 
[gw0] [ 78%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_null 
tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_false 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_invalid_types 
[gw8] [ 78%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_invalid_types 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_unknown_index 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_unknown 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_map 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_string 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_unknown 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_invalid_key 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_map 
[gw10] [ 78%] FAILED tests/values/test_values_operations.py::test_divide 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_divide_numbers 
[gw15] [ 78%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_divide_numbers 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_tuple 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_null 
[gw0] [ 78%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_null 
[gw23] [ 79%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_invalid_key 
[gw9] [ 79%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_string 
[gw16] [ 79%] FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_unknown 
tests/conversions/test_convert_2.py::TestBuiltinConversions::test_string_to_number_conversion 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_list 
[gw19] [ 79%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_list 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_invalid_type 
[gw18] [ 80%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_invalid_type 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_null 
[gw3] [ 80%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_null 
[gw4] [ 80%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo 
[gw5] [ 80%] FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_unknown 
[gw8] [ 80%] PASSED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_map 
[gw2] [ 81%] FAILED tests/values/test_values_operations.py::test_add_lists 
tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_invalid_type 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_tuple 
tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_unknown 
tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_missing 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_out_of_bounds 
[gw16] [ 81%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_out_of_bounds 
[gw21] [ 81%] FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_unknown_index 
[gw19] [ 81%] PASSED tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_missing 
tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_undefined 
[gw18] [ 81%] PASSED tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_undefined 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_invalid_type 
[gw9] [ 82%] PASSED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_invalid_type 
[gw13] [ 82%] FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_unknown 
[gw7] [ 82%] FAILED tests/conversions/test_convert_2.py::TestBuiltinConversions::test_string_to_number_conversion 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_map 
[gw5] [ 82%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_map 
[gw0] [ 83%] PASSED tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_invalid_type 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_unknown 
tests/values/test_values_operations_more.py::TestArithmeticOperations::test_subtract_numbers 
[gw2] [ 83%] PASSED tests/values/test_values_operations_more.py::TestArithmeticOperations::test_subtract_numbers 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_set 
[gw3] [ 83%] PASSED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_set 
[gw22] [ 83%] FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_unknown 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists 
[gw8] [ 83%] PASSED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_empty 
tests/values/test_values_operations.py::test_modulo 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_type_mismatch 
[gw17] [ 84%] FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_tuple 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_overlapping 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_null_unknown 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_null 
[gw13] [ 84%] PASSED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_null 
[gw21] [ 84%] PASSED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_type_mismatch 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists_empty 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string_null_unknown 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_type_mismatch 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string 
[gw3] [ 84%] PASSED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists_null_unknown 
[gw14] [ 85%] FAILED tests/values/test_values_operations_more.py::TestCollectionOperations::test_merge_maps 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string_invalid_types 
[gw8] [ 85%] PASSED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string_invalid_types 
[gw7] [ 85%] PASSED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists_empty 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_string_prefix_refinement 
[gw3] [ 85%] SKIPPED tests/values/test_values_refinement_2.py::TestValueRefinement::test_string_prefix_refinement 
tests/values/test_values_refinement.py::TestValueRefinements::test_compound_refinement 
[gw13] [ 85%] SKIPPED tests/values/test_values_refinement.py::TestValueRefinements::test_compound_refinement 
[gw20] [ 86%] FAILED tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_element_map 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list_invalid_types 
[gw21] [ 86%] PASSED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list_invalid_types 
[gw15] [ 86%] FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_tuple 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list_bounds 
[gw2] [ 86%] PASSED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list_bounds 
tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute 
[gw17] [ 87%] PASSED tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute 
[gw4] [ 87%] FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_unknown 
[gw12] [ 87%] FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_by_zero 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_list 
[gw14] [ 87%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_list 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_multiple_refinements 
tests/values/test_values_refinement.py::TestValueRefinements::test_refinement_builder 
[gw11] [ 87%] FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_by_zero 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_unknown 
[gw23] [ 88%] FAILED tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_unknown 
tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_null 
[gw20] [ 88%] PASSED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_null 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_null_value 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_unknown_value 
[gw5] [ 88%] FAILED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string_null_unknown 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists_type_mismatch 
[gw15] [ 88%] PASSED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists_type_mismatch 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_null_bounds 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string_bounds 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_null_index 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_builder_initialization 
[gw7] [ 89%] FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_refinement_builder 
[gw0] [ 89%] FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists_null_unknown 
[gw8] [ 89%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_multiple_refinements 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_known_value 
[gw13] [ 89%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_known_value 
[gw4] [ 89%] PASSED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string_bounds 
tests/values/test_values_refinement.py::TestValueRefinements::test_integration_with_operations 
tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_wrong_type 
[gw17] [ 90%] PASSED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_wrong_type 
[gw1] [ 90%] FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_map 
[gw20] [ 90%] PASSED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_builder_initialization 
[gw21] [ 90%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_null_value 
tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_set 
[gw11] [ 90%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_set 
[gw12] [ 91%] PASSED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_null_index 
[gw14] [ 91%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_null_bounds 
[gw3] [ 91%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_unknown_value 
[gw22] [ 91%] FAILED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_unknown 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_only_min 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_only_max 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_not_null_refinement 
[gw2] [ 92%] SKIPPED tests/values/test_values_refinement_2.py::TestValueRefinement::test_not_null_refinement 
[gw5] [ 92%] FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_integration_with_operations 
[gw16] [ 92%] FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_empty 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_with_decimal_numbers 
[gw13] [ 92%] SKIPPED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_with_decimal_numbers 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_string_prefix_refinement 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_multiple_refinements 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_list 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_wrong_type 
[gw4] [ 92%] PASSED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_wrong_type 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_unknown_value 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_not_null_refinement 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_null_bounds 
[gw1] [ 93%] PASSED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_list 
[gw7] [ 93%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_only_max 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_refinement 
[gw19] [ 93%] FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_type_mismatch 
[gw9] [ 93%] FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_overlapping 
tests/values/test_values_refinement.py::TestValueRefinements::test_integration_with_encoding 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_known_value 
[gw12] [ 94%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_known_value 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_null_value 
[gw10] [ 94%] FAILED tests/values/test_values_operations.py::test_modulo 
[gw20] [ 94%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_null_bounds 
tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_with_negative_numbers 
[gw18] [ 94%] FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_null_unknown 
[gw11] [ 94%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_unknown_value 
[gw15] [ 95%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_string_prefix_refinement 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_builder_initialization 
[gw13] [ 95%] PASSED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_builder_initialization 
[gw22] [ 95%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_refinement 
[gw14] [ 95%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_null_value 
[gw17] [ 96%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_multiple_refinements 
[gw21] [ 96%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_not_null_refinement 
[gw3] [ 96%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_with_negative_numbers 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_refinement 
[gw2] [ 96%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_refinement 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_only_min 
[gw0] [ 96%] FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_integration_with_encoding 
[gw8] [ 97%] FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_only_min 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_with_negative_numbers 
[gw6] [ 97%] FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_false 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list_null_unknown 
tests/values/test_values_refinement.py::TestValueRefinements::test_number_range_refinement 
tests/values/test_values_refinement.py::TestValueRefinements::test_not_null_refinement 
[gw19] [ 97%] SKIPPED tests/values/test_values_refinement.py::TestValueRefinements::test_not_null_refinement 
tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list 
tests/values/test_values_refinement.py::TestValueRefinements::test_string_prefix_refinement 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_only_max 
[gw5] [ 97%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_only_min 
tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_string 
[gw18] [ 98%] SKIPPED tests/values/test_values_refinement.py::TestValueRefinements::test_string_prefix_refinement 
[gw7] [ 98%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_with_negative_numbers 
[gw10] [ 98%] PASSED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_with_decimal_numbers 
[gw8] [ 98%] SKIPPED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_with_decimal_numbers 
[gw9] [ 98%] FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_number_range_refinement 
[gw6] [ 99%] PASSED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_string 
[gw23] [ 99%] FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps 
[gw16] [ 99%] FAILED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list_null_unknown 
[gw15] [ 99%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_only_max 
tests/values/test_values_refinement_3.py::TestValueRefinement::test_string_prefix_with_empty_prefix 
[gw23] [100%] FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_string_prefix_with_empty_prefix <sys>:0: RuntimeWarning: coroutine 'string_to_number' was never awaited
RuntimeWarning: Enable tracemalloc to get the object allocation traceback


==================================== ERRORS ====================================
__________ ERROR collecting tests/collections/test_collections_map.py __________
ImportError while importing test module '/Users/tim/code/pyvider-cty/tests/collections/test_collections_map.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
E   ModuleNotFoundError: No module named 'collections.test_collections_map'
__________ ERROR collecting tests/collections/test_collections_set.py __________
ImportError while importing test module '/Users/tim/code/pyvider-cty/tests/collections/test_collections_set.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
E   ModuleNotFoundError: No module named 'collections.test_collections_set'
________ ERROR collecting tests/conversions/test_conversion_registry.py ________
.venv/lib/python3.13/site-packages/_pytest/python.py:493: in importtestmodule
    mod = import_path(
.venv/lib/python3.13/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
<frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:935: in _load_unlocked
    ???
.venv/lib/python3.13/site-packages/_pytest/assertion/rewrite.py:176: in exec_module
    source_stat, co = _rewrite_test(fn, self.config)
.venv/lib/python3.13/site-packages/_pytest/assertion/rewrite.py:356: in _rewrite_test
    tree = ast.parse(source, filename=strfn)
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/ast.py:54: in parse
    return compile(source, filename, mode, flags,
E     File "/Users/tim/code/pyvider-cty/tests/conversions/test_conversion_registry.py", line 166
E       val = CtyValue(type_=CtyList(element_type=CtyString()), ["a", "b"])
E                                                                         ^
E   SyntaxError: positional argument follows keyword argument
_______ ERROR collecting tests/conversions/test_conversion_registry_2.py _______
.venv/lib/python3.13/site-packages/_pytest/python.py:493: in importtestmodule
    mod = import_path(
.venv/lib/python3.13/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
<frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:935: in _load_unlocked
    ???
.venv/lib/python3.13/site-packages/_pytest/assertion/rewrite.py:176: in exec_module
    source_stat, co = _rewrite_test(fn, self.config)
.venv/lib/python3.13/site-packages/_pytest/assertion/rewrite.py:356: in _rewrite_test
    tree = ast.parse(source, filename=strfn)
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/ast.py:54: in parse
    return compile(source, filename, mode, flags,
E     File "/Users/tim/code/pyvider-cty/tests/conversions/test_conversion_registry_2.py", line 166
E       val = CtyValue(type_=CtyList(element_type=CtyString()), ["a", "b"])
E                                                                         ^
E   SyntaxError: positional argument follows keyword argument
=================================== FAILURES ===================================
______________ TestConversionRegistry.test_convert_no_conversion _______________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x1102e2030>

    def test_convert_no_conversion(self):
        """Test converting a value with no available conversion."""
        # Mock value with type
        mock_value = MagicMock()
>       mock_value.type = self.mock_source_type
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:171: AttributeError
_________________ TestJsonEncoding.test_marshal_unknown_value __________________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x106c9ec40>

    def test_marshal_unknown_value(self):
        """Test marshaling an unknown value."""
        # Configure mock to be unknown
>       self.mock_value.is_known = False
E       AttributeError: 'TestJsonEncoding' object has no attribute 'mock_value'

tests/encoding/test_encoding_json.py:44: AttributeError
__________ TestPrimitiveConversions.test_string_to_number_known_value __________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_primitive.TestPrimitiveConversions object at 0x104fa3610>

    def test_string_to_number_known_value(self):
        """Test converting a known string value to number."""
        # Call string_to_number
>       with patch('pyvider.cty.convert.primitive.Number', return_value=self.mock_number):
E       AttributeError: 'TestPrimitiveConversions' object has no attribute 'mock_number'

tests/conversions/test_convert_primitive.py:28: AttributeError
__________ TestPrimitiveConversions.test_string_to_number_with_marks ___________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_primitive.TestPrimitiveConversions object at 0x103e6a690>

    def test_string_to_number_with_marks(self):
        """Test that marks are preserved when converting string to number."""
        # Configure mock with marks
>       self.mock_value._marks = frozenset(["sensitive", "encrypted"])
E       AttributeError: 'TestPrimitiveConversions' object has no attribute 'mock_value'

tests/conversions/test_convert_primitive.py:104: AttributeError
____________ TestConversionRegistry.test_register_unsafe_conversion ____________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x126bcf390>

    def test_register_unsafe_conversion(self):
        """Test registering an unsafe conversion."""
        # Register an unsafe conversion
        register_conversion(
>           source_type=self.mock_source_type,
            target_type=self.mock_target_type,
            converter=self.mock_converter,
            is_safe=False
        )
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:104: AttributeError
____________________ TestConversionSystem.test_unification _____________________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x107678cb0>

    @pytest.mark.asyncio
    async def test_unification(self):
        """Test type unification."""
        # Unify identical types
        types = [CtyString(), CtyString(), CtyString()]
        result = await unify(types)
        assert result is not None
        unified_type, conversions = result
        assert unified_type == CtyString
        assert len(conversions) == 3
    
        # Unify compatible types (all convert safely to string)
        types = [CtyBool(), CtyBool(), CtyNumber()]
        result = await unify(types)
        assert result is not None
        unified_type, conversions = result
>       assert unified_type == CtyString
E       AssertionError: assert <class 'pyvider.cty.types.primitives.number.CtyNumber'> == CtyString

tests/conversions/test_convert.py:158: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Attempting to unify 3 types
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Unified to CtyString
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Attempting to unify 3 types
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyNumber to CtyBool (unsafe=False)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  No conversion path found from CtyNumber to CtyBool
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyNumber to CtyBool (unsafe=False)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  No conversion path found from CtyNumber to CtyBool
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyBool to CtyNumber (unsafe=False)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyBool to CtyNumber (unsafe=False)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Unified to CtyNumber
______ TestConversionRegistry.test_convert_unsafe_with_unsafe_conversion _______
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x1102e1f20>

    def test_convert_unsafe_with_unsafe_conversion(self):
        """Test unsafe conversion with an unsafe conversion."""
        # Mock value with type
        mock_value = MagicMock()
>       mock_value.type = self.mock_source_type
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:184: AttributeError
____________ TestConversionRegistry.test_get_nonexistent_conversion ____________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x126eae520>

    def test_get_nonexistent_conversion(self):
        """Test getting a conversion that doesn't exist."""
        # Get a nonexistent conversion
>       conversion = get_conversion(self.mock_source_type, self.mock_target_type)
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:123: AttributeError
_____________________ TestConversion.test_conversion_init ______________________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversion object at 0x1103a3110>

    def test_conversion_init(self):
        """Test Conversion initialization."""
        # Assertions
>       self.assertEqual(self.conversion.source_type, self.mock_source_type)
E       AttributeError: 'TestConversion' object has no attribute 'assertEqual'

tests/conversions/test_convert_base.py:41: AttributeError
____________________ TestConversion.test_conversion_convert ____________________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversion object at 0x1103a2fd0>

    def test_conversion_convert(self):
        """Test Conversion.convert method."""
        # Call convert
>       result = self.conversion.convert(self.mock_value)
E       AttributeError: 'TestConversion' object has no attribute 'conversion'

tests/conversions/test_convert_base.py:49: AttributeError
_________________ TestConversionSystem.test_custom_conversion __________________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x1071056a0>

    @pytest.mark.asyncio
    async def test_custom_conversion(self):
        """Test registering and using a custom conversion."""
        # Define a custom conversion from string to list of strings
>       async def string_to_string_list(value: Value) -> Value:
E       NameError: name 'Value' is not defined

tests/conversions/test_convert.py:182: NameError
_______________ TestCtyMsgpackIntegration.test_encode_decode_map _______________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x1065df9b0>

    @pytest.mark.asyncio
    async def test_encode_decode_map(self):
        """Test encoding and decoding map values."""
        # Create map values
        string_type = CtyString()
        number_type = CtyNumber()
        map_type = CtyMap(key_type=string_type, value_type=number_type)
    
        test_values = [
            {},
            {"one": 1},
            {"one": 1, "two": 2, "three": 3},
            {"pi": Decimal("3.14159"), "e": Decimal("2.71828")}
        ]
    
        for value in test_values:
            # Create Cty map value
            elements = {
                CtyValue(string_type, raw_value=k): CtyValue(number_type, raw_value=Decimal(str(v)))
                for k, v in value.items()
            }
>           cty_value = CtyValue(map_type, raw_value=elements)
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:190: TypeError
___________________ TestJsonEncoding.test_marshal_null_value ___________________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x106c9eb10>

    def test_marshal_null_value(self):
        """Test marshaling a null value."""
        # Configure mock to be null
>       self.mock_value.is_null = True
E       AttributeError: 'TestJsonEncoding' object has no attribute 'mock_value'

tests/encoding/test_encoding_json.py:53: AttributeError
_________ TestPrimitiveConversions.test_string_to_number_unknown_value _________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_primitive.TestPrimitiveConversions object at 0x104fa2e90>

    def test_string_to_number_unknown_value(self):
        """Test converting an unknown string value to number."""
        # Configure mock to be unknown
>       self.mock_value.is_known = False
E       AttributeError: 'TestPrimitiveConversions' object has no attribute 'mock_value'

tests/conversions/test_convert_primitive.py:53: AttributeError
__________ TestPrimitiveConversions.test_string_to_number_null_value ___________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_primitive.TestPrimitiveConversions object at 0x10528a9e0>

    def test_string_to_number_null_value(self):
        """Test converting a null string value to number."""
        # Configure mock to be null
>       self.mock_value.is_null = True
E       AttributeError: 'TestPrimitiveConversions' object has no attribute 'mock_value'

tests/conversions/test_convert_primitive.py:71: AttributeError
___________ TestConversionRegistry.test_convert_unsafe_no_conversion ___________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x110525f50>

    def test_convert_unsafe_no_conversion(self):
        """Test unsafe conversion with no available conversion."""
        # Mock value with type
        mock_value = MagicMock()
>       mock_value.type = self.mock_source_type
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:208: AttributeError
_______________ TestConversionRegistry.test_multiple_conversions _______________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x110526750>

    def test_multiple_conversions(self):
        """Test registering multiple conversions."""
        # Create additional types
        mock_type2 = MagicMock()
        mock_type2.__class__ = type('MockType2', (), {})
    
        mock_type3 = MagicMock()
        mock_type3.__class__ = type('MockType3', (), {})
    
        # Register multiple conversions
        register_conversion(
>           source_type=self.mock_source_type,
            target_type=self.mock_target_type,
            converter=self.mock_converter,
            is_safe=True
        )
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:228: AttributeError
______________________ test_CtyList_validate_nested_lists ______________________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_CtyList_validate_nested_lists():
        nested_list = CtyList(element_type=CtyList(element_type=CtyString()))
        validated = nested_list.validate([["one", "two"], ["three"]])
>       assert validated == [["one", "two"], ["three"]]
E       AssertionError: assert [[CtyString()...[CtyString()]] == [['one', 'two'], ['three']]
E         
E         At index 0 diff: [CtyString(), CtyString()] != ['one', 'two']
E         
E         Full diff:
E           [
E               [
E         -         'one',...
E         
E         ...Full output truncated (9 lines hidden), use '-vv' to show

tests/list/test_cty_collections_list.py:24: AssertionError
______________ TestCtyMsgpackIntegration.test_encode_decode_type _______________
[gw18] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x113a42dd0>

    @pytest.mark.asyncio
    async def test_encode_decode_type(self):
        """Test encoding and decoding type definitions."""
        # Create test types
        string_type = CtyString()
        number_type = CtyNumber()
        list_type = CtyList(element_type=string_type)
        map_type = CtyMap(key_type=string_type, value_type=number_type)
        object_type = CtyObject(attribute_types={
            "name": string_type,
            "age": number_type
        })
    
        test_types = [string_type, number_type, list_type, map_type, object_type]
    
        for type_ in test_types:
            # Encode type
            encoded = await encode_type(type_)
            assert encoded is not None
            assert isinstance(encoded, bytes)
    
            # Decode type
            decoded = await decode_type(encoded)
            assert decoded is not None
>           assert isinstance(decoded, CtyType)
E           NameError: name 'CtyType' is not defined

tests/encoding/test_encoding_msgpack.py:485: NameError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding type: CtyString
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding type from MessagePack
_____________ TestCtyMsgpackIntegration.test_encode_decode_dynamic _____________
[gw17] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x10bab8350>

    @pytest.mark.asyncio
    async def test_encode_decode_dynamic(self):
        """Test encoding and decoding dynamic values."""
        # Create dynamic type
        dynamic_type = CtyDynamic()
    
        test_values = [
            "string value",
            42,
            3.14159,
            True,
            ["list", "of", "values"],
            {"key": "value"},
            None
        ]
    
        for value in test_values:
            # Create Cty dynamic value
>           cty_value = CtyValue(dynamic_type, raw_value=value)
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:361: TypeError
_____________ TestMsgpackEncoding.test_marshal_unmarshal_roundtrip _____________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

val = <pyvider.cty.values.base.CtyValue object at 0x107f4c6e0>, opts = None

    async def marshal(val: CtyValue, opts: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Marshal a Cty value to MessagePack with type information.
    
        This is a more comprehensive version of encode_value that includes
        type information, allowing for accurate round-trip serialization.
    
        Args:
            val: The Cty value to marshal
            opts: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
        """
        logger.debug(f" Marshaling Cty value: {val}")
    
        try:
            # Create a marshaled representation with type and value
            marshaled = {
>               "type": await encode_type(val.type),
                "value": await encode_value(val, opts),
                "is_known": val.is_known,
                "is_null": val.is_null,
            }
E           TypeError: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:458: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x10894ced0>

    @pytest.mark.asyncio
    async def test_marshal_unmarshal_roundtrip(self):
        """Test roundtrip marshaling and unmarshaling of a value."""
        # Create a value
        type_ = CtyString()
        value = CtyValue(type_=type_, value="test string")
    
        # Mock encode_type
        mock_encode_type = MagicMock(return_value=b'encoded type')
    
        # Mock encode_value
        mock_encode_value = MagicMock(return_value=b'encoded value')
    
        # Mock msgpack.packb for marshal
        mock_packb = MagicMock(return_value=b'marshaled data')
    
        # Mock msgpack.unpackb for unmarshal
        mock_unpackb = MagicMock(return_value={
            'type': b'encoded type',
            'value': b'encoded value',
            'is_known': True,
            'is_null': False
        })
    
        # Mock decode_type
        mock_decode_type = MagicMock(return_value=type_)
    
        # Mock decode_value
        mock_decode_value = MagicMock(return_value=value)
    
        with patch('pyvider.cty.encoding.msgpack.encode_type', mock_encode_type), \
             patch('pyvider.cty.encoding.msgpack.encode_value', mock_encode_value), \
             patch('msgpack.packb', mock_packb), \
             patch('msgpack.unpackb', mock_unpackb), \
             patch('pyvider.cty.encoding.msgpack.decode_type', mock_decode_type), \
             patch('pyvider.cty.encoding.msgpack.decode_value', mock_decode_value):
            # Marshal
>           marshaled = await marshal(value)

tests/encoding/test_encoding_msgpack_more.py:538: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

val = <pyvider.cty.values.base.CtyValue object at 0x107f4c6e0>, opts = None

    async def marshal(val: CtyValue, opts: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Marshal a Cty value to MessagePack with type information.
    
        This is a more comprehensive version of encode_value that includes
        type information, allowing for accurate round-trip serialization.
    
        Args:
            val: The Cty value to marshal
            opts: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
        """
        logger.debug(f" Marshaling Cty value: {val}")
    
        try:
            # Create a marshaled representation with type and value
            marshaled = {
                "type": await encode_type(val.type),
                "value": await encode_value(val, opts),
                "is_known": val.is_known,
                "is_null": val.is_null,
            }
    
            # Include marks if present
            if val.marks:
                marshaled["marks"] = [str(mark) for mark in val.marks]
    
            return msgpack.packb(marshaled, **(opts or DEFAULT_ENCODE_OPTIONS))
    
        except Exception as e:
            error_msg = f"Failed to marshal value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to marshal value: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:473: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Marshaling Cty value: <pyvider.cty.values.base.CtyValue object at 0x107f4c6e0>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to marshal value: object bytes can't be used in 'await' expression
__________________ TestFunctionSystem.test_function_registry ___________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_function_base.TestFunctionSystem object at 0x10316af90>

    @pytest.mark.asyncio
    async def test_function_registry(self):
        """Test function registry operations."""
        # Create a registry
        registry = FunctionRegistry()
    
        # Create a simple function
>       def return_string(args: List[CtyValue]) -> CtyType:
E       NameError: name 'CtyType' is not defined

tests/functions/test_function_base.py:291: NameError
_______________ TestConversionSystem.test_primitive_conversions ________________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x104522210>

    @pytest.mark.asyncio
    async def test_primitive_conversions(self):
        """Test conversions between primitive types."""
        # String to Number
        string_val = CtyValue(type_=CtyString(), value="42")
        number_result = await convert_unsafe(string_val, CtyNumber)
>       assert isinstance(number_result.type, CtyNumber)
E       AttributeError: 'coroutine' object has no attribute 'type'

tests/conversions/test_convert.py:41: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting value from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyString to CtyNumber (unsafe=True)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Conversion successful: <coroutine object string_to_number at 0x105060220>
________________ TestConversionSystem.test_invalid_conversions _________________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x104523250>

    @pytest.mark.asyncio
    async def test_invalid_conversions(self):
        """Test conversions that should fail."""
        # Invalid string to number
        string_val = CtyValue(type_=CtyString(), value="not a number")
>       with pytest.raises(ConversionError):
E       Failed: DID NOT RAISE <class 'pyvider.cty.exceptions.ConversionError'>

tests/conversions/test_convert.py:79: Failed
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting value from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyString to CtyNumber (unsafe=True)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Conversion successful: <coroutine object string_to_number at 0x105060a90>
______________ TestConversionSystem.test_conversion_path_finding _______________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x1071059d0>

    @pytest.mark.asyncio
    async def test_conversion_path_finding(self):
        """Test finding conversion paths through multiple steps."""
        # Define a custom multi-step conversion path
        # String -> Number -> Bool
    
        # First, ensure the direct String -> Bool conversion doesn't exist
        # (we'll remove it temporarily for this test)
        old_string_to_bool = registry._unsafe_conversions.pop((CtyString, CtyBool), None)
    
        try:
            # Now, find a path String -> Number -> Bool
            path = registry.find_conversion_path(CtyString, CtyBool, allow_unsafe=True)
            assert path is not None
            assert len(path) == 2
            assert path[0].source_type == CtyString
            assert path[0].target_type == CtyNumber
            assert path[1].source_type == CtyNumber
            assert path[1].target_type == CtyBool
    
            # Test the actual conversion
            string_val = CtyValue(type_=CtyString(), value="1")
            bool_result = await convert_unsafe(string_val, CtyBool)
>           assert isinstance(bool_result.type, CtyBool)
E           AttributeError: 'coroutine' object has no attribute 'type'

tests/conversions/test_convert.py:235: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyString to CtyBool (unsafe=True)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting value from CtyString to CtyBool
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyString to CtyBool (unsafe=True)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Conversion successful: <coroutine object string_to_number at 0x107561030>
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting from CtyNumber to CtyBool
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Conversion successful: <coroutine object number_to_bool at 0x1075343c0>
_____________ TestConversionRegistry.test_register_safe_conversion _____________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x1103a34d0>

    def test_register_safe_conversion(self):
        """Test registering a safe conversion."""
        # Register a safe conversion
        register_conversion(
>           source_type=self.mock_source_type,
            target_type=self.mock_target_type,
            converter=self.mock_converter,
            is_safe=True
        )
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:80: AttributeError
_______________ TestCtyListAdvanced.test_validate_tuple_as_list ________________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x111831450>

    def test_validate_tuple_as_list(self):
        """Test that validate accepts tuples and converts them to lists."""
        # Create a tuple of strings
        data = ("apple", "banana", "cherry")
    
        # Validate
>       result = self.string_list.validate(data)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'string_list'

tests/list/test_cty_collections_list_improve.py:28: AttributeError
_________________ TestMsgpackEncoding.test_encode_marked_value _________________
[gw20] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x113cd81a0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
>           if value.marks:
E           AttributeError: 'CtyValue' object has no attribute 'marks'. Did you mean: 'mark'?

src/pyvider/cty/encoding/msgpack.py:107: AttributeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x113b5b350>

    @pytest.mark.asyncio
    async def test_encode_marked_value(self):
        """Test encoding a marked value."""
        # Create a marked value
        value = CtyValue(type_=CtyString(), value="test", marks=frozenset(["sensitive"]))
    
        # Mock value.unmark
        unmarked_value = CtyValue(type_=CtyString(), value="test")
        mock_unmark = MagicMock(return_value=(unmarked_value, frozenset(["sensitive"])))
    
        # Mock encode_value for the unmarked value
        mock_encode_value = MagicMock(return_value=b'unmarked value data')
    
        # Mock msgpack.packb
        mock_packb_values = [b'marked data', b'final packed data']
        mock_packb = MagicMock(side_effect=mock_packb_values)
    
        with patch.object(value, 'unmark', mock_unmark), \
             patch('pyvider.cty.encoding.msgpack.encode_value', mock_encode_value), \
             patch('msgpack.packb', mock_packb):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x113cd81a0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x113cd81a0>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'
__________ TestCtyListAdvanced.test_validate_none_becomes_empty_list ___________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x11191cd60>

    def test_validate_none_becomes_empty_list(self):
        """Test that None is treated as an empty list."""
        # Validate None
>       result = self.string_list.validate(None)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'string_list'

tests/list/test_cty_collections_list_improve.py:37: AttributeError
________________ TestConversionRegistry.test_convert_same_type _________________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x126eae780>

    def test_convert_same_type(self):
        """Test converting a value to the same type."""
        # Mock value with type
        mock_value = MagicMock()
>       mock_value.type = self.mock_source_type
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:132: AttributeError
_____________ TestConversionRegistry.test_convert_with_conversion ______________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_base.TestConversionRegistry object at 0x126e4c830>

    def test_convert_with_conversion(self):
        """Test converting a value using a registered conversion."""
        # Mock value with type
        mock_value = MagicMock()
>       mock_value.type = self.mock_source_type
E       AttributeError: 'TestConversionRegistry' object has no attribute 'mock_source_type'

tests/conversions/test_convert_base.py:147: AttributeError
_________________________ test_CtyList_dynamic_schema __________________________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_CtyList_dynamic_schema():
        dynamic_list = CtyList(element_type=CtyList(CtyString()))
        validated = dynamic_list.validate([["one", "two"], ["three"]])
>       assert validated == [["one", "two"], ["three"]]
E       AssertionError: assert [[CtyString()...[CtyString()]] == [['one', 'two'], ['three']]
E         
E         At index 0 diff: [CtyString(), CtyString()] != ['one', 'two']
E         
E         Full diff:
E           [
E               [
E         -         'one',...
E         
E         ...Full output truncated (9 lines hidden), use '-vv' to show

tests/list/test_cty_collections_list.py:84: AssertionError
____________ TestConversionSystem.test_integration_with_operations _____________
[gw2] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x111922250>

    @pytest.mark.asyncio
    async def test_integration_with_operations(self):
        """Test that conversions work with value operations."""
        from pyvider.cty.values.operations import add, subtract, multiply, divide
    
        # Add a string representing a number to a number
        string_val = CtyValue(type_=CtyString(), value="10")
        number_val = CtyValue(type_=CtyNumber(), value=5)
    
        # This should convert the string to a number first
>       result = await add(string_val, number_val)

tests/conversions/test_convert.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = <pyvider.cty.values.base.CtyValue object at 0x11037e510>
b = <pyvider.cty.values.base.CtyValue object at 0x111b97ed0>

    def add(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Add two values together.
    
        Args:
            a: First value
            b: Second value
    
        Returns:
            Result of the addition
    
        Supported combinations:
        - Number + Number = Number (arithmetic addition)
        - String + String = String (concatenation)
        - list + list = list (concatenation)
    
        Raises:
            TypeError: If the operation is not supported for the given types
        """
        logger.debug(f" Adding {a} and {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            # For unknown values, return unknown of the expected result type
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                return CtyValue.unknown(CtyString())
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # For lists, ensure element types are compatible
                if a.type.element_type.equal(b.type.element_type):
                    return CtyValue.unknown(CtyList(element_type=a.type.element_type))
                else:
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
            else:
                raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            # For null values, return null of the expected result type
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                return CtyValue.null(CtyString())
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # For lists, ensure element types are compatible
                if a.type.element_type.equal(b.type.element_type):
                    return CtyValue.null(CtyList(element_type=a.type.element_type))
                else:
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
            else:
                raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
    
        # Handle actual addition
        try:
            # Number addition
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
                result = num_a + num_b
                logger.debug(f" Number addition result: {result}")
                return CtyValue(CtyNumber(), result)
    
            # String concatenation
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                result = str(a.value) + str(b.value)
                logger.debug(f" String concatenation result: {result}")
                return CtyValue(CtyString(), result)
    
            # list concatenation
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # Ensure element types are compatible
                if not a.type.element_type.equal(b.type.element_type):
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
    
                a_list = cast(list[Any], a.value)
                b_list = cast(list[Any], b.value)
                result = a_list + b_list
                logger.debug(f" list concatenation result: {result}")
                return CtyValue(CtyList(element_type=a.type.element_type), result)
    
            # Unsupported combination
            else:
>               raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
E               TypeError: Cannot add values of types CtyString and CtyNumber

src/pyvider/cty/values/operations.py:303: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Adding <pyvider.cty.values.base.CtyValue object at 0x11037e510> and <pyvider.cty.values.base.CtyValue object at 0x111b97ed0>
_________________ TestMsgpackEncoding.test_decode_complex_type _________________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

data = b'encoded type'

    async def decode_type(data: bytes) -> CtyType:
        """
        Decode MessagePack data to a Cty type.
    
        Args:
            data: MessagePack encoded type definition
    
        Returns:
            CtyType: The decoded Cty type
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(" Decoding type from MessagePack")
    
        try:
            type_info = msgpack.unpackb(data, **DEFAULT_DECODE_OPTIONS)
            type_name = type_info["type_name"]
    
            # Import the required types
            if type_name == "CtyString":
                return CtyString()
    
            elif type_name == "CtyNumber":
                return CtyNumber()
    
            elif type_name == "CtyBool":
                return CtyBool()
    
            elif type_name == "CtyList":
>               element_type = await decode_type(type_info["element_type"])
E               TypeError: object CtyString can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:402: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x110fdf110>

    @pytest.mark.asyncio
    async def test_decode_complex_type(self):
        """Test decoding a complex type with nested types."""
        # Mock decode_type for nested calls
        mock_element_type = CtyString()
        mock_decode_type = MagicMock(return_value=mock_element_type)
    
        # Mock msgpack.unpackb to return list type info
        mock_unpackb = MagicMock(return_value={
            'type_name': 'CtyList',
            'element_type': b'encoded element type'
        })
    
        with patch('pyvider.cty.encoding.msgpack.decode_type', mock_decode_type), \
             patch('msgpack.unpackb', mock_unpackb):
            # Decode type
>           result = await decode_type(b'encoded type')

tests/encoding/test_encoding_msgpack_more.py:481: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'encoded type'

    async def decode_type(data: bytes) -> CtyType:
        """
        Decode MessagePack data to a Cty type.
    
        Args:
            data: MessagePack encoded type definition
    
        Returns:
            CtyType: The decoded Cty type
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(" Decoding type from MessagePack")
    
        try:
            type_info = msgpack.unpackb(data, **DEFAULT_DECODE_OPTIONS)
            type_name = type_info["type_name"]
    
            # Import the required types
            if type_name == "CtyString":
                return CtyString()
    
            elif type_name == "CtyNumber":
                return CtyNumber()
    
            elif type_name == "CtyBool":
                return CtyBool()
    
            elif type_name == "CtyList":
                element_type = await decode_type(type_info["element_type"])
                return CtyList(element_type=element_type)
    
            elif type_name == "CtyMap":
                key_type = await decode_type(type_info["key_type"])
                value_type = await decode_type(type_info["value_type"])
                return CtyMap(key_type=key_type, value_type=value_type)
    
            elif type_name == "CtySet":
                element_type = await decode_type(type_info["element_type"])
                return CtySet(element_type=element_type)
    
            elif type_name == "CtyObject":
                attribute_types = {}
                for name, type_data in type_info["attribute_types"].items():
                    attribute_types[name] = await decode_type(type_data)
                return CtyObject(attribute_types=attribute_types)
    
            elif type_name == "CtyTuple":
                element_types = []
                for type_data in type_info["element_types"]:
                    element_types.append(await decode_type(type_data))
                return CtyTuple(element_types=tuple(element_types))
    
            elif type_name == "CtyDynamic":
                return CtyDynamic()
    
            else:
                logger.warning(f" Unknown type: {type_name}, returning dynamic")
                return CtyDynamic()
    
        except Exception as e:
            error_msg = f"Failed to decode type: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackDecodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackDecodeError: Failed to decode type: object CtyString can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:436: MsgpackDecodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding type from MessagePack
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode type: object CtyString can't be used in 'await' expression
________________ TestStdlibFunctions.test_conversion_functions _________________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_stdlib.TestStdlibFunctions object at 0x1110bc2b0>

    @pytest.mark.asyncio
    async def test_conversion_functions(self):
        """Test conversion functions."""
        # tostring
        tostring_fn = registry.get("tostring")
        assert tostring_fn is not None
    
        # Test with number
>       result = await tostring_fn(Value(type_=CtyNumber(), value=42))
E       NameError: name 'Value' is not defined

tests/functions/test_stdlib.py:288: NameError
_______________ TestFunctionSystem.test_integration_with_values ________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_function_base.TestFunctionSystem object at 0x1026e7790>

    @pytest.mark.asyncio
    async def test_integration_with_values(self):
        """Test function integration with the value system."""
        # Create a function to test a string
>       def return_bool(args: List[CtyValue]) -> CtyType:
E       NameError: name 'CtyType' is not defined

tests/functions/test_function_base.py:352: NameError
__________ TestCtyMsgpackIntegration.test_marshal_unmarshal_roundtrip __________
[gw18] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x113ad8bb0>

    @pytest.mark.asyncio
    async def test_marshal_unmarshal_roundtrip(self):
        """Test round-trip marshaling and unmarshaling of Cty values."""
        # Create complex object
        object_type = CtyObject(attribute_types={
            "name": CtyString(),
            "age": CtyNumber(),
            "tags": CtyList(element_type=CtyString()),
            "active": CtyBool(),
            "metadata": CtyMap(key_type=CtyString(), value_type=CtyDynamic())
        })
    
        # Create value
        object_value = {
>           "name": CtyValue(CtyString(), raw_value="Alice"),
            "age": CtyValue(CtyNumber(), raw_value=Decimal("30")),
            "tags": CtyValue(CtyList(element_type=CtyString()), raw_value=[
                CtyValue(CtyString(), raw_value="tag1"),
                CtyValue(CtyString(), raw_value="tag2")
            ]),
            "active": CtyValue(CtyBool(), raw_value=True),
            "metadata": CtyValue(CtyMap(key_type=CtyString(), value_type=CtyDynamic()), raw_value={
                CtyValue(CtyString(), raw_value="created"): CtyValue(CtyDynamic(), raw_value="2025-03-09")
            })
        }
E       TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:520: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
___________ TestMsgpackEncoding.test_encode_decode_roundtrip_string ____________
[gw22] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x1211502f0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
>           if value.marks:
E           AttributeError: 'CtyValue' object has no attribute 'marks'. Did you mean: 'mark'?

src/pyvider/cty/encoding/msgpack.py:107: AttributeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x1207bf590>

    @pytest.mark.asyncio
    async def test_encode_decode_roundtrip_string(self):
        """Test roundtrip encoding and decoding of a string value."""
        # Create a string value
        type_ = CtyString()
        value = CtyValue(type_=type_, value="test string")
    
        # For a real roundtrip test without mocking, we need msgpack
        # But we can still use mocks to avoid actual msgpack operations
        mock_encode = MagicMock(return_value=b'encoded data')
        mock_decode = MagicMock(return_value=value)
    
        with patch('pyvider.cty.encoding.msgpack.encode_value', mock_encode), \
             patch('pyvider.cty.encoding.msgpack.decode_value', mock_decode):
            # Encode
>           encoded = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x1211502f0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x1211502f0>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'
_________________ TestMsgpackEncoding.test_decode_string_value _________________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

data = b'encoded data', type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
>               return CtyValue(type_, raw_value=str(raw_value))
E               TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:275: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x116995e50>

    @pytest.mark.asyncio
    async def test_decode_string_value(self):
        """Test decoding a string value."""
        # Create string type
        type_ = CtyString()
    
        # Mock msgpack.unpackb
        mock_unpackb = MagicMock(return_value="decoded string")
    
        with patch('msgpack.unpackb', mock_unpackb):
            # Decode value
>           result = await decode_value(b'encoded data', type_)

tests/encoding/test_encoding_msgpack_more.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'encoded data', type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
                return CtyValue(type_, raw_value=str(raw_value))
    
            elif type_name == "CtyNumber":
                if isinstance(raw_value, int):
                    return CtyValue(type_, raw_value=Decimal(raw_value))
                return CtyValue(type_, raw_value=Decimal(str(raw_value)))
    
            elif type_name == "CtyBool":
                return CtyValue(type_, raw_value=bool(raw_value))
    
            # Collection types
            elif type_name == "CtyList":
                element_type = type_.element_type
                elements = []
                for element_data in raw_value:
                    element_val = await decode_value(msgpack.packb(element_data, **DEFAULT_ENCODE_OPTIONS), element_type)
                    elements.append(element_val)
                return CtyValue(type_, raw_value=elements)
    
            elif type_name == "CtyMap":
                key_type = type_.key_type
                value_type = type_.value_type
                items = {}
                for key_str, val_data in raw_value.items():
                    # MessagePack requires string keys
                    key_val = await decode_value(msgpack.packb(key_str, **DEFAULT_ENCODE_OPTIONS), key_type)
                    val_val = await decode_value(msgpack.packb(val_data, **DEFAULT_ENCODE_OPTIONS), value_type)
                    items[key_val] = val_val
                return CtyValue(type_, raw_value=items)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_data in raw_value.items():
                    attr_type = type_.attribute_types.get(attr_name, CtyDynamic())
                    attr_val = await decode_value(msgpack.packb(attr_data, **DEFAULT_ENCODE_OPTIONS), attr_type)
                    attributes[attr_name] = attr_val
                return CtyValue(type_, raw_value=attributes)
    
            # Dynamic - directly use the raw value
            elif type_name == "CtyDynamic":
                return CtyValue(type_, raw_value=raw_value)
    
            # Default handling
            return CtyValue(type_, raw_value=raw_value)
    
        except Exception as e:
            error_msg = f"Failed to decode MessagePack data: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackDecodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackDecodeError: Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:324: MsgpackDecodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding MessagePack data to CtyString
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'
_________________ TestFunctionSystem.test_parameter_validation _________________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_function_base.TestFunctionSystem object at 0x1088d8a50>

    @pytest.mark.asyncio
    async def test_parameter_validation(self):
        """Test parameter validation rules."""
        # Create parameter
        param = Parameter(
            name="test",
            type=CtyString(),
            allow_null=False,
            allow_unknown=False
        )
    
        # Test valid value
        valid_value = CtyValue(type_=CtyString(), value="test")
>       assert await param.validate(valid_value)

tests/functions/test_function_base.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Parameter(name='test', type=CtyString(), allow_null=False, allow_unknown=False, allow_dynamic_type=False)
value = <pyvider.cty.values.base.CtyValue object at 0x108a93ed0>

    async def validate(self, value: CtyValue) -> bool:
        """
        Validate a value against this parameter's rules.
    
        Args:
            value: The value to validate
    
        Returns:
            bool: True if valid, False otherwise
    
        Raises:
            ValidationError: If validation fails
        """
        # from pyvider.cty.values.base import Value
    
        logger.debug(f" Validating parameter {self.name} with value {value}")
    
        # Check for null
        if value.is_null and not self.allow_null:
            raise ValidationError(f"Parameter '{self.name}' cannot be null")
    
        # Check for unknown
>       if value.is_unknown and not self.allow_unknown:
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

src/pyvider/cty/function/base.py:80: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]       cty.function.base   |  Validating parameter test with value <pyvider.cty.values.base.CtyValue object at 0x108a93ed0>
_______________ TestCtyMsgpackIntegration.test_encode_decode_set _______________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x1071caf10>

    @pytest.mark.asyncio
    async def test_encode_decode_set(self):
        """Test encoding and decoding set values."""
        # Create set values
        string_type = CtyString()
        set_type = CtySet(element_type=string_type)
    
        test_values = [
            set(),
            {"one"},
            {"one", "two", "three"},
            {"", "empty"},
            {"special", "chars: !@#$"}
        ]
    
        for value in test_values:
            # Create Cty set value
            elements = {Value(string_type, raw_value=item) for item in value}
>           cty_value = CtyValue(set_type, raw_value=elements)
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:233: TypeError
_____________ TestCtyMsgpackIntegration.test_encode_decode_object ______________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x1071cb020>

    @pytest.mark.asyncio
    async def test_encode_decode_object(self):
        """Test encoding and decoding object values."""
        # Create object type with mixed attributes
        object_type = CtyObject(attribute_types={
            "name": CtyString(),
            "age": CtyNumber(),
            "active": CtyBool()
        })
    
        test_values = [
            {
                "name": "Alice",
                "age": Decimal("30"),
                "active": True
            },
            {
                "name": "Bob",
                "age": Decimal("25"),
                "active": False
            },
            {
                "name": "",
                "age": Decimal("0"),
                "active": False
            }
        ]
    
        for value in test_values:
            # Create Cty object value
            attributes = {
>               "name": CtyValue(CtyString(), raw_value=value["name"]),
                "age": CtyValue(CtyNumber(), raw_value=value["age"]),
                "active": CtyValue(CtyBool(), raw_value=value["active"])
            }
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:283: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
________ TestPrimitiveConversions.test_string_to_number_invalid_string _________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_primitive.TestPrimitiveConversions object at 0x10528a8b0>

    def test_string_to_number_invalid_string(self):
        """Test converting an invalid string value to number."""
        # Configure mock with invalid number string
>       self.mock_value._value = "not_a_number"
E       AttributeError: 'TestPrimitiveConversions' object has no attribute 'mock_value'

tests/conversions/test_convert_primitive.py:89: AttributeError
______________ TestCtyListAdvanced.test_element_at_negative_index ______________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1052735c0>

    def test_element_at_negative_index(self):
        """Test retrieving an element at a negative index."""
        # Create and validate a list
        data = ["apple", "banana", "cherry"]
>       validated = self.string_list.validate(data)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'string_list'

tests/list/test_cty_collections_list_improve.py:120: AttributeError
____________ TestCtyListAdvanced.test_element_at_invalid_container _____________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1053c98d0>

    def test_element_at_invalid_container(self):
        """Test element_at with an invalid container."""
        # Try to get element from non-list
>       with self.assertRaises(ValidationError):
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertRaises'

tests/list/test_cty_collections_list_improve.py:131: AttributeError
_____________ TestConversionSystem.test_null_and_unknown_handling ______________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x1045b4e90>

    @pytest.mark.asyncio
    async def test_null_and_unknown_handling(self):
        """Test that null and unknown values are handled correctly."""
        # Null string to number
        null_string = CtyValue(type_=CtyString(), is_null=True)
        null_number = await convert_unsafe(null_string, CtyNumber)
>       assert null_number.is_null
E       AttributeError: 'coroutine' object has no attribute 'is_null'

tests/conversions/test_convert.py:99: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting value from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyString to CtyNumber (unsafe=True)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Converting from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Conversion successful: <coroutine object string_to_number at 0x105061d50>
__________________ TestStdlibFunctions.test_string_functions ___________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_stdlib.TestStdlibFunctions object at 0x1031311d0>

    @pytest.mark.asyncio
    async def test_string_functions(self):
        """Test string manipulation functions."""
        # upper
        upper_fn = registry.get("upper")
        assert upper_fn is not None
    
>       result = await upper_fn(Value(type_=CtyString(), value="hello"))
E       NameError: name 'Value' is not defined

tests/functions/test_stdlib.py:36: NameError
__________________ TestJsonEncoding.test_unmarshal_null_data ___________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x1042b2360>

    def test_unmarshal_null_data(self):
        """Test unmarshaling null data."""
        # Mock the null_val function
>       with patch('pyvider.cty.encoding.json.null_val') as mock_null_val:

tests/encoding/test_encoding_json.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1495: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x104162350>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'pyvider.cty.encoding.json' from '/Users/tim/code/pyvider-cty/src/pyvider/cty/encoding/json.py'> does not have the attribute 'null_val'

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1465: AttributeError
_________________ TestJsonEncoding.test_unmarshal_invalid_json _________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x104716a50>

    def test_unmarshal_invalid_json(self):
        """Test unmarshaling invalid JSON data."""
        # Call unmarshal with invalid JSON
>       with self.assertRaises(ValueError):
E       AttributeError: 'TestJsonEncoding' object has no attribute 'assertRaises'

tests/encoding/test_encoding_json.py:112: AttributeError
_________________ TestJsonEncoding.test_marshal_complex_value __________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x104716b50>

    def test_marshal_complex_value(self):
        """Test marshaling a complex value."""
        # Configure mock with complex data
>       self.mock_value._value = {
            "string": "value",
            "number": 123,
            "boolean": True,
            "list": [1, 2, 3],
            "object": {"nested": "value"}
        }
E       AttributeError: 'TestJsonEncoding' object has no attribute 'mock_value'

tests/encoding/test_encoding_json.py:118: AttributeError
_____________ TestConversionSystem.test_integration_with_functions _____________
[gw2] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x11036b890>

    @pytest.mark.asyncio
    async def test_integration_with_functions(self):
        """Test that conversions work with functions."""
        from pyvider.cty.function.base import (
            Parameter,
            FunctionSpec,
            Function,
        )
    
        # Create a function that takes a number and returns a string
        def return_string(args):
            return CtyString()
    
        def format_number(args, return_type):
            # Format the number with two decimal places
            num = args[0].value
            if isinstance(num, Decimal):
                result = f"{num:.2f}"
            else:
                result = f"{Decimal(str(num)):.2f}"
    
            return CtyValue(type_=return_type, value=result)
    
        spec = FunctionSpec(
            name="format_number",
            params=[
                Parameter(name="num", type=CtyNumber(), allow_null=False, allow_unknown=True)
            ],
            return_type_fn=return_string,
            implementation=format_number,
            description="Format a number with two decimal places"
        )
    
        format_fn = Function(spec)
    
        # Test with a normal number
>       result = await format_fn(Value(type_=CtyNumber(), value=42.5))
E       NameError: name 'Value' is not defined

tests/conversions/test_convert.py:347: NameError
____________ TestPrimitiveConversions.test_register_conversion_call ____________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_primitive.TestPrimitiveConversions object at 0x103ae2140>

    def test_register_conversion_call(self):
        """Test that register_conversion is called for string_to_number."""
        with patch('pyvider.cty.convert.primitive.register_conversion') as mock_register:
            # Import the module again to trigger the registration
            from importlib import reload
            from pyvider.cty.convert import primitive
            reload(primitive)
    
            # Assertions - check that register_conversion was called
>           mock_register.assert_called()

tests/conversions/test_convert_primitive.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='register_conversion' id='4359258528'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'register_conversion' to have been called.

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:946: AssertionError
__________________ TestJsonEncoding.test_marshal_known_value ___________________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x103adf9d0>

    def test_marshal_known_value(self):
        """Test marshaling a known value."""
        # Call marshal
>       result = marshal(self.mock_value)
E       AttributeError: 'TestJsonEncoding' object has no attribute 'mock_value'

tests/encoding/test_encoding_json.py:26: AttributeError
_______________ TestCtyListAdvanced.test_equal_same_element_type _______________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1053c9b70>

    def test_equal_same_element_type(self):
        """Test equality with same element type."""
        # Create another string list
        other_string_list = CtyList(element_type=CtyString())
    
        # Test equality
>       self.assertTrue(self.string_list.equal(other_string_list))
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertTrue'

tests/list/test_cty_collections_list_improve.py:140: AttributeError
________________ TestCtyListAdvanced.test_string_representation ________________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x110698230>

    def test_string_representation(self):
        """Test string representation of CtyList."""
        # Create a list type
        list_type = CtyList(element_type=CtyString())
    
        # Test string representation
>       self.assertEqual(str(list_type), "list(CtyString)")
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertEqual'

tests/list/test_cty_collections_list_improve.py:182: AttributeError
____________ TestCtyListAdvanced.test_string_representation_complex ____________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1106982d0>

    def test_string_representation_complex(self):
        """Test string representation of complex CtyList."""
        # Create a nested list type
        nested_list = CtyList(element_type=CtyList(element_type=CtyNumber()))
    
        # Test string representation
>       self.assertEqual(str(nested_list), "list(list(CtyNumber))")
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertEqual'

tests/list/test_cty_collections_list_improve.py:190: AttributeError
_______________ TestCtyListAdvanced.test_list_equality_operator ________________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1105b9fd0>

    def test_list_equality_operator(self):
        """Test the __eq__ operator."""
        # Create two identical list types
        list1 = CtyList(element_type=CtyString())
        list2 = CtyList(element_type=CtyString())
    
        # Test equality
>       self.assertEqual(list1, list2)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertEqual'

tests/list/test_cty_collections_list_improve.py:199: AttributeError
___________ TestCtyListAdvanced.test_validate_invalid_container_type ___________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x11191ce90>

    def test_validate_invalid_container_type(self):
        """Test validation fails for non-list/tuple containers."""
        # Try to validate a dictionary
>       with self.assertRaises(PyviderError):
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertRaises'

tests/list/test_cty_collections_list_improve.py:45: AttributeError
______________ TestCtyListAdvanced.test_validate_homogeneous_list ______________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x11193ef90>

    def test_validate_homogeneous_list(self):
        """Test validation of a homogeneous list."""
        # Create a list of numbers
        data = [1, 2, 3, 4, 5]
    
        # Validate
>       result = self.number_list.validate(data)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'number_list'

tests/list/test_cty_collections_list_improve.py:58: AttributeError
________________ TestStdlibFunctions.test_filesystem_functions _________________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_stdlib.TestStdlibFunctions object at 0x110fa9490>

    @pytest.mark.asyncio
    async def test_filesystem_functions(self):
        """Test filesystem functions."""
        # Create a temporary file for testing
        with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
            temp_file.write("Hello, Terraform!")
            temp_path = temp_file.name
    
        try:
            # file
            file_fn = registry.get("file")
            assert file_fn is not None
    
>           result = await file_fn(Value(type_=CtyString(), value=temp_path))
E           NameError: name 'Value' is not defined

tests/functions/test_stdlib.py:355: NameError
________________ TestCtyMsgpackIntegration.test_error_handling _________________
[gw18] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x111ff7290>

    @pytest.mark.asyncio
    async def test_error_handling(self):
        """Test error handling during encoding and decoding."""
        # Test encoding with invalid value
        string_type = CtyString()
        invalid_value = "Not a Value object"
    
        with pytest.raises(MsgpackEncodeError):
            await encode_value(invalid_value)
    
        # Test decoding with invalid data
        invalid_data = b"Not valid MessagePack data"
    
        with pytest.raises(MsgpackDecodeError):
            await decode_value(invalid_data, string_type)
    
        # Test type mismatch during decoding
>       string_value = CtyValue(string_type, raw_value="test")
E       TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:587: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: Not a Value object
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'str' object has no attribute 'is_known'
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding MessagePack data to CtyString
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode MessagePack data: unpack(b) received extra data.
__________________ TestMsgpackEncoding.test_encode_list_value __________________
[gw20] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x114873b10>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
>           if value.marks:
E           AttributeError: 'CtyValue' object has no attribute 'marks'. Did you mean: 'mark'?

src/pyvider/cty/encoding/msgpack.py:107: AttributeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x113b5b460>

    @pytest.mark.asyncio
    async def test_encode_list_value(self):
        """Test encoding a list value."""
        # Create a list value
        value = CtyValue(type_=CtyList(element_type=CtyString()), value=["a", "b", "c"])
    
        # Mock encode_value for each element
        mock_encode_value = MagicMock(return_value=b'encoded element')
    
        # Mock msgpack.packb
        mock_packb = MagicMock(return_value=b'packed list')
    
        with patch('pyvider.cty.encoding.msgpack.encode_value', mock_encode_value), \
             patch('msgpack.packb', mock_packb):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x114873b10>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x114873b10>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'
__________________ TestMsgpackEncoding.test_encode_map_value ___________________
[gw20] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x1148739d0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
>           if value.marks:
E           AttributeError: 'CtyValue' object has no attribute 'marks'. Did you mean: 'mark'?

src/pyvider/cty/encoding/msgpack.py:107: AttributeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x113e3cc50>

    @pytest.mark.asyncio
    async def test_encode_map_value(self):
        """Test encoding a map value."""
        # Create a map value
        value = CtyValue(
            type_=CtyMap(key_type=CtyString(), value_type=CtyNumber()),
            value={"a": 1, "b": 2}
        )
    
        # Mock encode_value for each item
        mock_encode_value = MagicMock(return_value=b'encoded value')
    
        # Mock msgpack.packb
        mock_packb = MagicMock(return_value=b'packed map')
    
        with patch('pyvider.cty.encoding.msgpack.encode_value', mock_encode_value), \
             patch('msgpack.packb', mock_packb):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x1148739d0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x1148739d0>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'
__________________ TestConvertFunctions.test_convert_function __________________
[gw6] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x108758050>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'convert' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConvertFunctions object at 0x1085cead0>

    @pytest.mark.asyncio
    async def test_convert_function(self):
        """Test the convert function."""
        # Mock registry.convert
        mock_result = CtyValue(CtyNumber(), 123)
        mock_convert = MagicMock(return_value=mock_result)
    
>       with patch('pyvider.cty.convert.convert.registry.convert', mock_convert):

tests/conversions/test_convert_2.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x108758050>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'convert' is read-only"), <traceback object at 0x109ae6b80>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'convert' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
_________________ TestMsgpackEncoding.test_encode_number_value _________________
[gw19] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x10cdfa510>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
>           if value.marks:
E           AttributeError: 'CtyValue' object has no attribute 'marks'. Did you mean: 'mark'?

src/pyvider/cty/encoding/msgpack.py:107: AttributeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x10d2202d0>

    @pytest.mark.asyncio
    async def test_encode_number_value(self):
        """Test encoding a number value."""
        # Create a number value
        value = CtyValue(type_=CtyNumber(), value=Decimal("123.45"))
    
        # Mock msgpack.packb
        mock_packb = MagicMock(return_value=b'test packed data')
    
        with patch('msgpack.packb', mock_packb):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x10cdfa510>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x10cdfa510>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'
__________________ TestMsgpackEncoding.test_encode_bool_value __________________
[gw19] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x10d3bbb10>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
>           if value.marks:
E           AttributeError: 'CtyValue' object has no attribute 'marks'. Did you mean: 'mark'?

src/pyvider/cty/encoding/msgpack.py:107: AttributeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x10d1eba80>

    @pytest.mark.asyncio
    async def test_encode_bool_value(self):
        """Test encoding a boolean value."""
        # Create a boolean value
        value = CtyValue(type_=CtyBool(), value=True)
    
        # Mock msgpack.packb
        mock_packb = MagicMock(return_value=b'test packed data')
    
        with patch('msgpack.packb', mock_packb):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x10d3bbb10>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x10d3bbb10>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'
_________________ TestJsonEncoding.test_unmarshal_string_data __________________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x106c6bad0>

    def test_unmarshal_string_data(self):
        """Test unmarshaling from string data."""
        # Mock the null_val function
>       with patch('pyvider.cty.encoding.json.null_val') as mock_null_val:

tests/encoding/test_encoding_json.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1495: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x105e9a490>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'pyvider.cty.encoding.json' from '/Users/tim/code/pyvider-cty/src/pyvider/cty/encoding/json.py'> does not have the attribute 'null_val'

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1465: AttributeError
__________________ TestJsonEncoding.test_unmarshal_bytes_data __________________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x1068e2250>

    def test_unmarshal_bytes_data(self):
        """Test unmarshaling from bytes data."""
        # Mock the Value constructor
        with patch('pyvider.cty.encoding.json.CtyValue') as mock_value_class:
            # Set up mock return value
            mock_value_instance = MagicMock()
            mock_value_class.return_value = mock_value_instance
    
            # Set up mock validate
            validated_value = "validated_value"
>           self.mock_type.validate.return_value = validated_value
E           AttributeError: 'TestJsonEncoding' object has no attribute 'mock_type'

tests/encoding/test_encoding_json.py:85: AttributeError
________________ TestCtyListAdvanced.test_validate_nested_lists ________________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x106e8c5a0>

    def test_validate_nested_lists(self):
        """Test validation of nested lists."""
        # Create a list of lists
>       nested_list_type = CtyList(element_type=self.string_list)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'string_list'

tests/list/test_cty_collections_list_improve.py:75: AttributeError
______________ TestCtyMsgpackIntegration.test_encode_decode_tuple ______________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x1074e0250>

    @pytest.mark.asyncio
    async def test_encode_decode_tuple(self):
        """Test encoding and decoding tuple values."""
        # Create tuple type with mixed element types
>       tuple_type = CtyTuple(element_types=(CtyString(), CtyNumber(), CtyBool()))
E       TypeError: CtyTuple.__init__() got an unexpected keyword argument 'element_types'

tests/encoding/test_encoding_msgpack.py:310: TypeError
______________ TestConversionSystem.test_collection_type_handling ______________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert.TestConversionSystem object at 0x107622050>

    @pytest.mark.asyncio
    async def test_collection_type_handling(self):
        """Test conversion with collection types."""
        # Create a list of strings
        string_list = CtyValue(
            type_=CtyList(element_type=CtyString()),
            value=["1", "2", "3"]
        )
    
        # Custom conversion from list of strings to list of numbers
>       async def string_list_to_number_list(value: Value) -> Value:
E       NameError: name 'Value' is not defined

tests/conversions/test_convert.py:253: NameError
_________________ TestCtyListAdvanced.test_equal_non_list_type _________________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x107794410>

    def test_equal_non_list_type(self):
        """Test equality with non-list type."""
        # Create a CtyString
        string_type = CtyString()
    
        # Test inequality
>       self.assertFalse(self.string_list.equal(string_type))
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertFalse'

tests/list/test_cty_collections_list_improve.py:153: AttributeError
_________________ TestCtyListAdvanced.test_usable_as_same_type _________________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1077944d0>

    def test_usable_as_same_type(self):
        """Test usable_as with same type."""
        # Create another string list
        other_string_list = CtyList(element_type=CtyString())
    
        # Test usability
>       self.assertTrue(self.string_list.usable_as(other_string_list))
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertTrue'

tests/list/test_cty_collections_list_improve.py:161: AttributeError
______________ TestCtyListAdvanced.test_usable_as_different_type _______________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x107603120>

    def test_usable_as_different_type(self):
        """Test usable_as with different type."""
        # Test non-usability
>       self.assertFalse(self.string_list.usable_as(self.number_list))
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertFalse'

tests/list/test_cty_collections_list_improve.py:166: AttributeError
____________ TestCtyListAdvanced.test_equal_different_element_type _____________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1052ec530>

    def test_equal_different_element_type(self):
        """Test equality with different element type."""
        # Test inequality
>       self.assertFalse(self.string_list.equal(self.number_list))
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertFalse'

tests/list/test_cty_collections_list_improve.py:145: AttributeError
____________ TestConvertFunctions.test_can_convert_unsafe_function _____________
[gw7] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x104f34050>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConvertFunctions object at 0x10585ec30>

    @pytest.mark.asyncio
    async def test_can_convert_unsafe_function(self):
        """Test the can_convert_unsafe function."""
        # Mock registry.find_conversion_path
        mock_path = [MagicMock()]
        mock_find = MagicMock(return_value=mock_path)
    
>       with patch('pyvider.cty.convert.convert.registry.find_conversion_path', mock_find):

tests/conversions/test_convert_2.py:417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x104f34050>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'find_conversion_path' is read-only"), <traceback object at 0x105a01bc0>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
__________________ TestStdlibFunctions.test_crypto_functions ___________________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_stdlib.TestStdlibFunctions object at 0x110d87ce0>

    @pytest.mark.asyncio
    async def test_crypto_functions(self):
        """Test crypto functions."""
        # base64encode
        base64encode_fn = registry.get("base64encode")
        assert base64encode_fn is not None
    
>       result = await base64encode_fn(Value(type_=CtyString(), value="Hello, Terraform!"))
E       NameError: name 'Value' is not defined

tests/functions/test_stdlib.py:396: NameError
__________ TestCtyListAdvanced.test_post_init_validates_element_type ___________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x126ed9590>

    def test_post_init_validates_element_type(self):
        """Test that __post_init__ validates element_type is a CtyType."""
        # Try to create a CtyList with an invalid element_type
>       with self.assertRaises(PyviderError):
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertRaises'

tests/list/test_cty_collections_list_improve.py:19: AttributeError
_________________ TestCtyListAdvanced.test_repr_representation _________________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x126fcaf50>

    def test_repr_representation(self):
        """Test __repr__ representation."""
        # Test repr
>       self.assertEqual(repr(self.string_list), "CtyList()")
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertEqual'

tests/list/test_cty_collections_list_improve.py:209: AttributeError
____________ TestCtyListWithNestedTypes.test_list_of_tuples_invalid ____________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListWithNestedTypes object at 0x126eda0d0>

    def test_list_of_tuples_invalid(self):
        """Test a list of tuples with invalid data."""
        # Create a tuple type
        tuple_type = CtyTuple((str, int))
    
        # Create a list of tuples type
        list_of_tuples = CtyList(element_type=tuple_type)
    
        # Create invalid data (wrong tuple structure)
        data = [("a", 1), ("b", "not_an_int"), ("c", 3)]
    
        # Validate
>       with self.assertRaises(ValidationError):
E       AttributeError: 'TestCtyListWithNestedTypes' object has no attribute 'assertRaises'

tests/list/test_cty_collections_list_improve.py:244: AttributeError
_________________ TestMsgpackEncoding.test_decode_number_value _________________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

data = b'encoded data', type_ = CtyNumber(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
                return CtyValue(type_, raw_value=str(raw_value))
    
            elif type_name == "CtyNumber":
                if isinstance(raw_value, int):
                    return CtyValue(type_, raw_value=Decimal(raw_value))
>               return CtyValue(type_, raw_value=Decimal(str(raw_value)))
E               TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:280: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x116996210>

    @pytest.mark.asyncio
    async def test_decode_number_value(self):
        """Test decoding a number value."""
        # Create number type
        type_ = CtyNumber()
    
        # Mock msgpack.unpackb
        mock_unpackb = MagicMock(return_value=123.45)
    
        with patch('msgpack.unpackb', mock_unpackb):
            # Decode value
>           result = await decode_value(b'encoded data', type_)

tests/encoding/test_encoding_msgpack_more.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'encoded data', type_ = CtyNumber(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
                return CtyValue(type_, raw_value=str(raw_value))
    
            elif type_name == "CtyNumber":
                if isinstance(raw_value, int):
                    return CtyValue(type_, raw_value=Decimal(raw_value))
                return CtyValue(type_, raw_value=Decimal(str(raw_value)))
    
            elif type_name == "CtyBool":
                return CtyValue(type_, raw_value=bool(raw_value))
    
            # Collection types
            elif type_name == "CtyList":
                element_type = type_.element_type
                elements = []
                for element_data in raw_value:
                    element_val = await decode_value(msgpack.packb(element_data, **DEFAULT_ENCODE_OPTIONS), element_type)
                    elements.append(element_val)
                return CtyValue(type_, raw_value=elements)
    
            elif type_name == "CtyMap":
                key_type = type_.key_type
                value_type = type_.value_type
                items = {}
                for key_str, val_data in raw_value.items():
                    # MessagePack requires string keys
                    key_val = await decode_value(msgpack.packb(key_str, **DEFAULT_ENCODE_OPTIONS), key_type)
                    val_val = await decode_value(msgpack.packb(val_data, **DEFAULT_ENCODE_OPTIONS), value_type)
                    items[key_val] = val_val
                return CtyValue(type_, raw_value=items)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_data in raw_value.items():
                    attr_type = type_.attribute_types.get(attr_name, CtyDynamic())
                    attr_val = await decode_value(msgpack.packb(attr_data, **DEFAULT_ENCODE_OPTIONS), attr_type)
                    attributes[attr_name] = attr_val
                return CtyValue(type_, raw_value=attributes)
    
            # Dynamic - directly use the raw value
            elif type_name == "CtyDynamic":
                return CtyValue(type_, raw_value=raw_value)
    
            # Default handling
            return CtyValue(type_, raw_value=raw_value)
    
        except Exception as e:
            error_msg = f"Failed to decode MessagePack data: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackDecodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackDecodeError: Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:324: MsgpackDecodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding MessagePack data to CtyNumber
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'
___________ TestCtyMsgpackIntegration.test_encode_decode_null_values ___________
[gw17] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

data = b'\xc7\x15\x01\x81\xa9type_name\xa9CtyString', type_ = CtyString()
options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
>               return CtyValue(type_, raw_value=str(raw_value))
E               TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:275: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x10ba95400>

    @pytest.mark.asyncio
    async def test_encode_decode_null_values(self):
        """Test encoding and decoding null values of various types."""
        # Create test types
        string_type = CtyString()
        number_type = CtyNumber()
        bool_type = CtyBool()
        list_type = CtyList(element_type=string_type)
        map_type = CtyMap(key_type=string_type, value_type=number_type)
    
        test_types = [string_type, number_type, bool_type, list_type, map_type]
    
        for type_ in test_types:
            # Create null value
            null_value = CtyValue(type_, is_null=True)
    
            # Encode to MessagePack
            encoded = await encode_value(null_value)
            assert encoded is not None
            assert isinstance(encoded, bytes)
    
            # Decode from MessagePack
>           decoded = await decode_value(encoded, type_)

tests/encoding/test_encoding_msgpack.py:402: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xc7\x15\x01\x81\xa9type_name\xa9CtyString', type_ = CtyString()
options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
                return CtyValue(type_, raw_value=str(raw_value))
    
            elif type_name == "CtyNumber":
                if isinstance(raw_value, int):
                    return CtyValue(type_, raw_value=Decimal(raw_value))
                return CtyValue(type_, raw_value=Decimal(str(raw_value)))
    
            elif type_name == "CtyBool":
                return CtyValue(type_, raw_value=bool(raw_value))
    
            # Collection types
            elif type_name == "CtyList":
                element_type = type_.element_type
                elements = []
                for element_data in raw_value:
                    element_val = await decode_value(msgpack.packb(element_data, **DEFAULT_ENCODE_OPTIONS), element_type)
                    elements.append(element_val)
                return CtyValue(type_, raw_value=elements)
    
            elif type_name == "CtyMap":
                key_type = type_.key_type
                value_type = type_.value_type
                items = {}
                for key_str, val_data in raw_value.items():
                    # MessagePack requires string keys
                    key_val = await decode_value(msgpack.packb(key_str, **DEFAULT_ENCODE_OPTIONS), key_type)
                    val_val = await decode_value(msgpack.packb(val_data, **DEFAULT_ENCODE_OPTIONS), value_type)
                    items[key_val] = val_val
                return CtyValue(type_, raw_value=items)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_data in raw_value.items():
                    attr_type = type_.attribute_types.get(attr_name, CtyDynamic())
                    attr_val = await decode_value(msgpack.packb(attr_data, **DEFAULT_ENCODE_OPTIONS), attr_type)
                    attributes[attr_name] = attr_val
                return CtyValue(type_, raw_value=attributes)
    
            # Dynamic - directly use the raw value
            elif type_name == "CtyDynamic":
                return CtyValue(type_, raw_value=raw_value)
    
            # Default handling
            return CtyValue(type_, raw_value=raw_value)
    
        except Exception as e:
            error_msg = f"Failed to decode MessagePack data: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackDecodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackDecodeError: Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:324: MsgpackDecodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x10bc87b10>
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding null value
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding type: CtyString
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding MessagePack data to CtyString
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding null value
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'
_________ TestCtyMsgpackIntegration.test_encode_decode_unknown_values __________
[gw17] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

data = b'\xc7#\x00\x82\xa4type\xc4\x15\x81\xa9type_name\xa9CtyString\xa4path\x90'
type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
>               return CtyValue(type_, raw_value=str(raw_value))
E               TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:275: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x10ba95d60>

    @pytest.mark.asyncio
    async def test_encode_decode_unknown_values(self):
        """Test encoding and decoding unknown values of various types."""
        # Create test types
        string_type = CtyString()
        number_type = CtyNumber()
        bool_type = CtyBool()
        list_type = CtyList(element_type=string_type)
        map_type = CtyMap(key_type=string_type, value_type=number_type)
    
        test_types = [string_type, number_type, bool_type, list_type, map_type]
    
        for type_ in test_types:
            # Create unknown value
            unknown_value = CtyValue(type_, is_unknown=True)
    
            # Encode to MessagePack
            encoded = await encode_value(unknown_value)
            assert encoded is not None
            assert isinstance(encoded, bytes)
    
            # Decode from MessagePack
>           decoded = await decode_value(encoded, type_)

tests/encoding/test_encoding_msgpack.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xc7#\x00\x82\xa4type\xc4\x15\x81\xa9type_name\xa9CtyString\xa4path\x90'
type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
                return CtyValue(type_, raw_value=str(raw_value))
    
            elif type_name == "CtyNumber":
                if isinstance(raw_value, int):
                    return CtyValue(type_, raw_value=Decimal(raw_value))
                return CtyValue(type_, raw_value=Decimal(str(raw_value)))
    
            elif type_name == "CtyBool":
                return CtyValue(type_, raw_value=bool(raw_value))
    
            # Collection types
            elif type_name == "CtyList":
                element_type = type_.element_type
                elements = []
                for element_data in raw_value:
                    element_val = await decode_value(msgpack.packb(element_data, **DEFAULT_ENCODE_OPTIONS), element_type)
                    elements.append(element_val)
                return CtyValue(type_, raw_value=elements)
    
            elif type_name == "CtyMap":
                key_type = type_.key_type
                value_type = type_.value_type
                items = {}
                for key_str, val_data in raw_value.items():
                    # MessagePack requires string keys
                    key_val = await decode_value(msgpack.packb(key_str, **DEFAULT_ENCODE_OPTIONS), key_type)
                    val_val = await decode_value(msgpack.packb(val_data, **DEFAULT_ENCODE_OPTIONS), value_type)
                    items[key_val] = val_val
                return CtyValue(type_, raw_value=items)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_data in raw_value.items():
                    attr_type = type_.attribute_types.get(attr_name, CtyDynamic())
                    attr_val = await decode_value(msgpack.packb(attr_data, **DEFAULT_ENCODE_OPTIONS), attr_type)
                    attributes[attr_name] = attr_val
                return CtyValue(type_, raw_value=attributes)
    
            # Dynamic - directly use the raw value
            elif type_name == "CtyDynamic":
                return CtyValue(type_, raw_value=raw_value)
    
            # Default handling
            return CtyValue(type_, raw_value=raw_value)
    
        except Exception as e:
            error_msg = f"Failed to decode MessagePack data: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackDecodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackDecodeError: Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:324: MsgpackDecodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x10b9f0d60>
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding unknown value
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding type: CtyString
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding MessagePack data to CtyString
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding unknown value
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'
__________ TestCtyListAdvanced.test_validate_nested_list_with_errors ___________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x106cb6f50>

    def test_validate_nested_list_with_errors(self):
        """Test validation of nested lists with errors."""
        # Create a list of lists with an error in the nested list
>       nested_list_type = CtyList(element_type=self.number_list)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'number_list'

tests/list/test_cty_collections_list_improve.py:87: AttributeError
______________ TestCtyListAdvanced.test_usable_as_different_type _______________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_advanced.TestCtyListAdvanced testMethod=test_usable_as_different_type>

    def test_usable_as_different_type(self):
        """Test usable_as with different type."""
        # Test non-usability
>       self.assertFalse(self.string_list.usable_as(self.number_list))

tests/list/test_list_advanced.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CtyList(), other = CtyList()

    def usable_as(self, other: "CtyType") -> bool:
        """
        Checks if this tuple type can be used as another type.
    
        Args:
            other (CtyType): Another type to check compatibility with.
    
        Returns:
            bool: True if compatible, False otherwise.
        """
        return isinstance(other, CtyList) and all(
            issubclass(self_type, other_type)
>           for self_type, other_type in zip(self.types, other.types)
        )
E       AttributeError: 'CtyList' object has no attribute 'types'. Did you mean: 'ctype'?

src/pyvider/cty/types/collections/list.py:84: AttributeError
__________________ TestFunctionSystem.test_variadic_parameter __________________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_function_base.TestFunctionSystem object at 0x1088d8910>

    @pytest.mark.asyncio
    async def test_variadic_parameter(self):
        """Test variadic parameter validation."""
        # Create variadic parameter
        variadic = VariadicParameter(
            name="args",
            type=CtyNumber(),
            min_elements=1,
            max_elements=3,
            allow_null=False,
            allow_unknown=True,
        )
    
        # Create test values
        values = [
            CtyValue(type_=CtyNumber(), value=1),
            CtyValue(type_=CtyNumber(), value=2),
            CtyValue(type_=CtyNumber(), is_unknown=True)
        ]
    
        # Test valid values
>       assert await variadic.validate_all(values)

tests/functions/test_function_base.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/pyvider/cty/function/base.py:154: in validate_all
    await self.validate(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = VariadicParameter(name='args', type=CtyNumber(), allow_null=False, allow_unknown=True, allow_dynamic_type=False, min_elements=1, max_elements=3)
value = <pyvider.cty.values.base.CtyValue object at 0x108a93d90>

    async def validate(self, value: CtyValue) -> bool:
        """
        Validate a value against this parameter's rules.
    
        Args:
            value: The value to validate
    
        Returns:
            bool: True if valid, False otherwise
    
        Raises:
            ValidationError: If validation fails
        """
        # from pyvider.cty.values.base import Value
    
        logger.debug(f" Validating parameter {self.name} with value {value}")
    
        # Check for null
        if value.is_null and not self.allow_null:
            raise ValidationError(f"Parameter '{self.name}' cannot be null")
    
        # Check for unknown
>       if value.is_unknown and not self.allow_unknown:
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

src/pyvider/cty/function/base.py:80: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]       cty.function.base   |  Validating variadic parameter args with 3 values
2025-03-12 17:00:12    [DEBUG]       cty.function.base   |  Validating parameter args with value <pyvider.cty.values.base.CtyValue object at 0x108a93d90>
____________________ TestFunctionSystem.test_function_spec _____________________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_function_base.TestFunctionSystem object at 0x108813bb0>

    @pytest.mark.asyncio
    async def test_function_spec(self):
        """Test function specification and validation."""
        # Create a simple function to add two numbers
>       def return_number(args: List[CtyValue]) -> CtyType:
E       NameError: name 'CtyType' is not defined

tests/functions/test_function_base.py:132: NameError
__________________ TestStdlibFunctions.test_numeric_functions __________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_stdlib.TestStdlibFunctions object at 0x103131090>

    @pytest.mark.asyncio
    async def test_numeric_functions(self):
        """Test numeric functions."""
        # abs
        abs_fn = registry.get("abs")
        assert abs_fn is not None
    
>       result = await abs_fn(Value(type_=CtyNumber(), value=-42))
E       NameError: name 'Value' is not defined

tests/functions/test_stdlib.py:116: NameError
_____________ TestCtyMsgpackIntegration.test_encode_decode_string ______________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x107dd3b10>

    @pytest.mark.asyncio
    async def test_encode_decode_string(self):
        """Test encoding and decoding string values."""
        # Create string values
        string_type = CtyString()
        test_values = [
            "Hello, world!",
            "",
            "Special chars: ",
            "Symbols: !@#$%^&*()",
            "1234567890"
        ]
    
        for value in test_values:
            # Create a Cty string value
>           cty_value = CtyValue(string_type, raw_value=value)
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:50: TypeError
_____________ TestCtyMsgpackIntegration.test_encode_decode_number ______________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x1142e0190>

    @pytest.mark.asyncio
    async def test_encode_decode_number(self):
        """Test encoding and decoding number values."""
        # Create number values
        number_type = CtyNumber()
        test_values = [
            0,
            42,
            -42,
            3.14159,
            -3.14159,
            Decimal("123456789.987654321"),
            Decimal("-123456789.987654321")
        ]
    
        for value in test_values:
            # Convert to Decimal for consistency
            decimal_value = value if isinstance(value, Decimal) else Decimal(str(value))
    
            # Create a Cty number value
>           cty_value = CtyValue(number_type, raw_value=decimal_value)
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:84: TypeError
______________ TestCtyMsgpackIntegration.test_encode_decode_bool _______________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x1142af490>

    @pytest.mark.asyncio
    async def test_encode_decode_bool(self):
        """Test encoding and decoding boolean values."""
        # Create boolean values
        bool_type = CtyBool()
        test_values = [True, False]
    
        for value in test_values:
            # Create a Cty boolean value
>           cty_value = CtyValue(bool_type, raw_value=value)
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:119: TypeError
________________ TestMsgpackEncoding.test_encode_unknown_value _________________
[gw19] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x10d3bb9d0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
>               type_bytes = await encode_type(value.type)
E               TypeError: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:94: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x10d1eb950>

    @pytest.mark.asyncio
    async def test_encode_unknown_value(self):
        """Test encoding an unknown value."""
        # Create an unknown value
        value = CtyValue(type_=CtyString(), is_unknown=True)
    
        # Mock msgpack.packb for both operations
        mock_packb_values = [b'encoded type data', b'final encoded data']
        mock_packb = MagicMock(side_effect=mock_packb_values)
    
        # Mock encode_type
        mock_encode_type = MagicMock(return_value=b'type bytes')
    
        with patch('msgpack.packb', mock_packb), \
             patch('pyvider.cty.encoding.msgpack.encode_type', mock_encode_type):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x10d3bb9d0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x10d3bb9d0>
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding unknown value
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: object bytes can't be used in 'await' expression
____________ TestMsgpackEncoding.test_decode_with_ext_hook_unknown _____________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

data = b'encoded data', type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
>               return CtyValue(type_, raw_value=str(raw_value))
E               TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:275: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x1169b98d0>

    @pytest.mark.asyncio
    async def test_decode_with_ext_hook_unknown(self):
        """Test decoding an unknown value using ext_hook."""
        # Create test data that would trigger the ext_hook
        # This is a bit tricky to test directly, so we'll just verify the correct handling
        type_ = CtyString()
    
        # Mock msgpack.unpackb to return an unknown value through ext_hook
        # We'll need to capture and call the ext_hook
        ext_hook = None
    
        def mock_unpackb(data, **kwargs):
            nonlocal ext_hook
            ext_hook = kwargs['ext_hook']
            # Create ExtType for unknown value
            from msgpack import ExtType
            dummy_data = msgpack.packb({
                "type": b"type data",
                "path": []
            })
            return ext_hook(EXT_UNKNOWN, dummy_data)
    
        with patch('msgpack.unpackb', mock_unpackb):
            # Decode value
>           result = await decode_value(b'encoded data', type_)

tests/encoding/test_encoding_msgpack_more.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'encoded data', type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
                return CtyValue(type_, raw_value=str(raw_value))
    
            elif type_name == "CtyNumber":
                if isinstance(raw_value, int):
                    return CtyValue(type_, raw_value=Decimal(raw_value))
                return CtyValue(type_, raw_value=Decimal(str(raw_value)))
    
            elif type_name == "CtyBool":
                return CtyValue(type_, raw_value=bool(raw_value))
    
            # Collection types
            elif type_name == "CtyList":
                element_type = type_.element_type
                elements = []
                for element_data in raw_value:
                    element_val = await decode_value(msgpack.packb(element_data, **DEFAULT_ENCODE_OPTIONS), element_type)
                    elements.append(element_val)
                return CtyValue(type_, raw_value=elements)
    
            elif type_name == "CtyMap":
                key_type = type_.key_type
                value_type = type_.value_type
                items = {}
                for key_str, val_data in raw_value.items():
                    # MessagePack requires string keys
                    key_val = await decode_value(msgpack.packb(key_str, **DEFAULT_ENCODE_OPTIONS), key_type)
                    val_val = await decode_value(msgpack.packb(val_data, **DEFAULT_ENCODE_OPTIONS), value_type)
                    items[key_val] = val_val
                return CtyValue(type_, raw_value=items)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_data in raw_value.items():
                    attr_type = type_.attribute_types.get(attr_name, CtyDynamic())
                    attr_val = await decode_value(msgpack.packb(attr_data, **DEFAULT_ENCODE_OPTIONS), attr_type)
                    attributes[attr_name] = attr_val
                return CtyValue(type_, raw_value=attributes)
    
            # Dynamic - directly use the raw value
            elif type_name == "CtyDynamic":
                return CtyValue(type_, raw_value=raw_value)
    
            # Default handling
            return CtyValue(type_, raw_value=raw_value)
    
        except Exception as e:
            error_msg = f"Failed to decode MessagePack data: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackDecodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackDecodeError: Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:324: MsgpackDecodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding MessagePack data to CtyString
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding unknown value
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'
_______________ TestCtyListAdvanced.test_element_at_valid_index ________________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x106cb7050>

    def test_element_at_valid_index(self):
        """Test retrieving an element at a valid index."""
        # Create and validate a list
        data = ["apple", "banana", "cherry"]
>       validated = self.string_list.validate(data)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'string_list'

tests/list/test_cty_collections_list_improve.py:98: AttributeError
_________________ TestMsgpackEncoding.test_encode_complex_type _________________
[gw22] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

type_ = CtyList()

    async def encode_type(type_: CtyType) -> bytes:
        """
        Encode a Cty type definition to MessagePack.
    
        Args:
            type_: The Cty type to encode
    
        Returns:
            bytes: MessagePack encoded type definition
        """
        logger.debug(f" Encoding type: {type_.__class__.__name__}")
    
        try:
            type_info = {
                "type_name": type_.__class__.__name__
            }
    
            # Include additional type information
            if hasattr(type_, "element_type"):
>               type_info["element_type"] = await encode_type(type_.element_type)
E               TypeError: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:346: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x12122c9f0>

    @pytest.mark.asyncio
    async def test_encode_complex_type(self):
        """Test encoding a complex type with nested types."""
        # Create a complex type
        type_ = CtyList(element_type=CtyMap(key_type=CtyString(), value_type=CtyNumber()))
    
        # Mock encode_type for nested calls
        mock_encode_type_values = [b'key type', b'value type', b'element type']
        mock_encode_type = MagicMock(side_effect=mock_encode_type_values)
    
        # Mock msgpack.packb
        mock_packb = MagicMock(return_value=b'packed type')
    
        with patch('pyvider.cty.encoding.msgpack.encode_type', mock_encode_type), \
             patch('msgpack.packb', mock_packb):
            # Encode type
>           result = await encode_type(type_)

tests/encoding/test_encoding_msgpack_more.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

type_ = CtyList()

    async def encode_type(type_: CtyType) -> bytes:
        """
        Encode a Cty type definition to MessagePack.
    
        Args:
            type_: The Cty type to encode
    
        Returns:
            bytes: MessagePack encoded type definition
        """
        logger.debug(f" Encoding type: {type_.__class__.__name__}")
    
        try:
            type_info = {
                "type_name": type_.__class__.__name__
            }
    
            # Include additional type information
            if hasattr(type_, "element_type"):
                type_info["element_type"] = await encode_type(type_.element_type)
    
            if hasattr(type_, "key_type") and hasattr(type_, "value_type"):
                type_info["key_type"] = await encode_type(type_.key_type)
                type_info["value_type"] = await encode_type(type_.value_type)
    
            if hasattr(type_, "attribute_types"):
                attr_types = {}
                for name, attr_type in type_.attribute_types.items():
                    attr_types[name] = await encode_type(attr_type)
                type_info["attribute_types"] = attr_types
    
            if hasattr(type_, "element_types"):
                element_types = []
                for elem_type in type_.element_types:
                    element_types.append(await encode_type(elem_type))
                type_info["element_types"] = element_types
    
            return msgpack.packb(type_info, **DEFAULT_ENCODE_OPTIONS)
    
        except Exception as e:
            error_msg = f"Failed to encode type: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode type: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:369: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding type: CtyList
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode type: object bytes can't be used in 'await' expression
_______________ TestCtyListAdvanced.test_element_at_valid_index ________________
[gw22] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_advanced.TestCtyListAdvanced testMethod=test_element_at_valid_index>

    def test_element_at_valid_index(self):
        """Test retrieving an element at a valid index."""
        # Create and validate a list
        data = ["apple", "banana", "cherry"]
        validated = self.string_list.validate(data)
    
        # Get element at index
        element = self.string_list.element_at(validated, 1)
    
        # Assertions
>       self.assertEqual(element, "banana")
E       AssertionError: CtyString() != 'banana'

tests/list/test_list_advanced.py:105: AssertionError
______________ TestStdlibFunctions.test_null_and_unknown_handling ______________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_stdlib.TestStdlibFunctions object at 0x111134380>

    @pytest.mark.asyncio
    async def test_null_and_unknown_handling(self):
        """Test that functions handle null and unknown values correctly."""
        # Test with null
        upper_fn = registry.get("upper")
>       result = await upper_fn(Value(type_=CtyString(), is_null=True))
E       NameError: name 'Value' is not defined

tests/functions/test_stdlib.py:432: NameError
_________________ TestMsgpackEncoding.test_encode_string_value _________________
[gw18] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x113920050>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
>           if value.marks:
E           AttributeError: 'CtyValue' object has no attribute 'marks'. Did you mean: 'mark'?

src/pyvider/cty/encoding/msgpack.py:107: AttributeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x113a30410>

    @pytest.mark.asyncio
    async def test_encode_string_value(self):
        """Test encoding a string value."""
        # Create a string value
        value = CtyValue(type_=CtyString(), value="test string")
    
        # Mock msgpack.packb
        mock_packb = MagicMock(return_value=b'test packed data')
    
        with patch('msgpack.packb', mock_packb):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x113920050>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x113920050>
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: 'CtyValue' object has no attribute 'marks'
_____________ TestCtyListWithNestedTypes.test_empty_list_elements ______________
[gw18] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListWithNestedTypes object at 0x113b150f0>

    def test_empty_list_elements(self):
        """Test a list with empty list elements."""
        # Create a nested list type
        list_of_strings = CtyList(element_type=CtyString())
        list_of_lists = CtyList(element_type=list_of_strings)
    
        # Create data with an empty list
        data = [["a", "b"], [], ["c", "d"]]
    
        # Validate
        result = list_of_lists.validate(data)
    
        # Assertions
>       self.assertEqual(result, data)
E       AttributeError: 'TestCtyListWithNestedTypes' object has no attribute 'assertEqual'

tests/list/test_cty_collections_list_improve.py:275: AttributeError
_________________ TestConversionRegistry.test_registry_convert _________________
[gw5] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x105f73ed0>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConversionRegistry object at 0x105d22650>

    @pytest.mark.asyncio
    async def test_registry_convert(self):
        """Test converting a value."""
        # Mock the find_conversion_path method
        mock_path = [
            MagicMock(spec=Conversion)
        ]
        mock_path[0].convert = MagicMock()
        mock_path[0].convert.return_value = CtyValue(CtyNumber(), 123)
    
>       with patch.object(registry, 'find_conversion_path', return_value=mock_path):

tests/conversions/test_convert_2.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x105f73ed0>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'find_conversion_path' is read-only"), <traceback object at 0x10592b780>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
___________________ TestJsonEncoding.test_marshal_with_type ____________________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x103adf750>

    def test_marshal_with_type(self):
        """Test marshaling with explicit type."""
        # Call marshal with type
>       result = marshal(self.mock_value, self.mock_type)
E       AttributeError: 'TestJsonEncoding' object has no attribute 'mock_value'

tests/encoding/test_encoding_json.py:35: AttributeError
_________________ TestJsonEncoding.test_unmarshal_complex_data _________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_json.TestJsonEncoding object at 0x1041675c0>

    def test_unmarshal_complex_data(self):
        """Test unmarshaling complex data."""
        # Complex JSON data
        complex_data = {
            "string": "value",
            "number": 123,
            "boolean": True,
            "list": [1, 2, 3],
            "object": {"nested": "value"}
        }
    
        # Mock CtyValue constructor and type.validate
        with patch('pyvider.cty.encoding.json.CtyValue') as mock_value_class:
            # Set up mock return value
            mock_value_instance = MagicMock()
            mock_value_class.return_value = mock_value_instance
    
            # Set up mock validate to return the input
>           self.mock_type.validate.return_value = complex_data
E           AttributeError: 'TestJsonEncoding' object has no attribute 'mock_type'

tests/encoding/test_encoding_json.py:151: AttributeError
_____________ TestCtyListWithNestedTypes.test_empty_list_elements ______________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_with_nested_types.TestCtyListWithNestedTypes testMethod=test_empty_list_elements>

    def test_empty_list_elements(self):
        """Test a list with empty list elements."""
        # Create a nested list type
        list_of_strings = CtyList(element_type=CtyString())
        list_of_lists = CtyList(element_type=list_of_strings)
    
        # Create data with an empty list
        data = [["a", "b"], [], ["c", "d"]]
    
        # Validate
        result = list_of_lists.validate(data)
    
        # Assertions
>       self.assertEqual(result, data)
E       AssertionError: Lists differ: [[CtyString(), CtyString()], [], [CtyString(), CtyString()]] != [['a', 'b'], [], ['c', 'd']]
E       
E       First differing element 0:
E       [CtyString(), CtyString()]
E       ['a', 'b']
E       
E       - [[CtyString(), CtyString()], [], [CtyString(), CtyString()]]
E       + [['a', 'b'], [], ['c', 'd']]

tests/list/test_list_with_nested_types.py:81: AssertionError
___________ TestCtyListWithNestedTypes.test_list_of_lists_of_strings ___________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_with_nested_types.TestCtyListWithNestedTypes testMethod=test_list_of_lists_of_strings>

    def test_list_of_lists_of_strings(self):
        """Test a list of lists of strings."""
        # Create a nested list type
        list_of_strings = CtyList(element_type=CtyString())
        list_of_lists = CtyList(element_type=list_of_strings)
    
        # Create data
        data = [["a", "b"], ["c", "d", "e"], ["f"]]
    
        # Validate
        result = list_of_lists.validate(data)
    
        # Assertions
>       self.assertEqual(result, data)
E       AssertionError: Lists differ: [[CtyString(), CtyString()], [CtyString(), [36 chars]g()]] != [['a', 'b'], ['c', 'd', 'e'], ['f']]
E       
E       First differing element 0:
E       [CtyString(), CtyString()]
E       ['a', 'b']
E       
E       + [['a', 'b'], ['c', 'd', 'e'], ['f']]
E       - [[CtyString(), CtyString()],
E       -  [CtyString(), CtyString(), CtyString()],
E       -  [CtyString()]]

tests/list/test_list_with_nested_types.py:62: AssertionError
_______________ TestCtyListAdvanced.test_usable_as_non_list_type _______________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x107603330>

    def test_usable_as_non_list_type(self):
        """Test usable_as with non-list type."""
        # Create a CtyString
        string_type = CtyString()
    
        # Test non-usability
>       self.assertFalse(self.string_list.usable_as(string_type))
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertFalse'

tests/list/test_cty_collections_list_improve.py:174: AttributeError
___________ TestCtyListWithNestedTypes.test_list_of_lists_of_strings ___________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListWithNestedTypes object at 0x126f14fc0>

    def test_list_of_lists_of_strings(self):
        """Test a list of lists of strings."""
        # Create a nested list type
        list_of_strings = CtyList(element_type=CtyString())
        list_of_lists = CtyList(element_type=list_of_strings)
    
        # Create data
        data = [["a", "b"], ["c", "d", "e"], ["f"]]
    
        # Validate
        result = list_of_lists.validate(data)
    
        # Assertions
>       self.assertEqual(result, data)
E       AttributeError: 'TestCtyListWithNestedTypes' object has no attribute 'assertEqual'

tests/list/test_cty_collections_list_improve.py:260: AttributeError
________________ TestCtyListWithNestedTypes.test_list_of_tuples ________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_with_nested_types.TestCtyListWithNestedTypes testMethod=test_list_of_tuples>

    def test_list_of_tuples(self):
        """Test a list of tuples."""
        # Create a tuple type
        tuple_type = CtyTuple((str, int))
    
        # Create a list of tuples type
        list_of_tuples = CtyList(element_type=tuple_type)
    
        # Create data
        data = [("a", 1), ("b", 2), ("c", 3)]
    
        # Validate
        try:
            result = list_of_tuples.validate(data)
            # Check that values match
            self.assertEqual(len(result), 3)
>           self.assertEqual(result[0], ("a", 1))
E           AssertionError: None != ('a', 1)

tests/list/test_list_with_nested_types.py:28: AssertionError

During handling of the above exception, another exception occurred:

self = <list.test_list_with_nested_types.TestCtyListWithNestedTypes testMethod=test_list_of_tuples>

    def test_list_of_tuples(self):
        """Test a list of tuples."""
        # Create a tuple type
        tuple_type = CtyTuple((str, int))
    
        # Create a list of tuples type
        list_of_tuples = CtyList(element_type=tuple_type)
    
        # Create data
        data = [("a", 1), ("b", 2), ("c", 3)]
    
        # Validate
        try:
            result = list_of_tuples.validate(data)
            # Check that values match
            self.assertEqual(len(result), 3)
            self.assertEqual(result[0], ("a", 1))
            self.assertEqual(result[1], ("b", 2))
            self.assertEqual(result[2], ("c", 3))
        except Exception as e:
>           self.fail(f"Validation raised exception: {e}")
E           AssertionError: Validation raised exception: None != ('a', 1)

tests/list/test_list_with_nested_types.py:32: AssertionError
______________ TestCtyListAdvanced.test_element_at_invalid_index _______________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x106c874d0>

    def test_element_at_invalid_index(self):
        """Test retrieving an element at an invalid index."""
        # Create and validate a list
        data = ["apple", "banana", "cherry"]
>       validated = self.string_list.validate(data)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'string_list'

tests/list/test_cty_collections_list_improve.py:110: AttributeError
_________________ TestCtyListAdvanced.test_usable_as_same_type _________________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_advanced.TestCtyListAdvanced testMethod=test_usable_as_same_type>

    def test_usable_as_same_type(self):
        """Test usable_as with same type."""
        # Create another string list
        other_string_list = CtyList(element_type=CtyString())
    
        # Test usability
>       self.assertTrue(self.string_list.usable_as(other_string_list))

tests/list/test_list_advanced.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CtyList(), other = CtyList()

    def usable_as(self, other: "CtyType") -> bool:
        """
        Checks if this tuple type can be used as another type.
    
        Args:
            other (CtyType): Another type to check compatibility with.
    
        Returns:
            bool: True if compatible, False otherwise.
        """
        return isinstance(other, CtyList) and all(
            issubclass(self_type, other_type)
>           for self_type, other_type in zip(self.types, other.types)
        )
E       AttributeError: 'CtyList' object has no attribute 'types'. Did you mean: 'ctype'?

src/pyvider/cty/types/collections/list.py:84: AttributeError
________________________ test_CtyList_validate_success _________________________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_CtyList_validate_success():
        string_list = CtyList(element_type=CtyString())
        validated = string_list.validate(["apple", "banana", "cherry"])
>       assert validated == ["apple", "banana", "cherry"]
E       AssertionError: assert [CtyString(),..., CtyString()] == ['apple', 'banana', 'cherry']
E         
E         At index 0 diff: CtyString() != 'apple'
E         
E         Full diff:
E           [
E         -     'apple',
E         -     'banana',...
E         
E         ...Full output truncated (5 lines hidden), use '-vv' to show

tests/list/test_cty_collections_list.py:13: AssertionError
______________ TestCtyListAdvanced.test_list_inequality_operator _______________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x1106eacd0>

    def test_list_inequality_operator(self):
        """Test inequality with different element types."""
        # Test inequality
>       self.assertNotEqual(self.string_list, self.number_list)
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertNotEqual'

tests/list/test_cty_collections_list_improve.py:204: AttributeError
______________________ test_ctyobject_get_valid_attribute ______________________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_ctyobject_get_valid_attribute():
        """Test attribute access for valid attributes."""
        # Setup object type and data
        obj = CtyObject({
            "title": CtyString(),
            "level": CtyNumber()
        })
    
        data = obj.validate({"title": "Game Title", "level": 5})
    
        # Access attribute
        attr_value = obj.get_attribute(data, "title")
    
        # Verify attribute value
>       assert attr_value == "Game Title"
E       AssertionError: assert CtyString() == 'Game Title'

tests/object/test_cty_structural_object.py:187: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'title': 'Game Title', 'level': 5}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'level', 'title'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute title with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute title: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute level with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute level: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'title': CtyString(), 'level': CtyNumber()}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Getting attribute title from object
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Found attribute title: CtyString
________________ TestStdlibFunctions.test_collection_functions _________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_stdlib.TestStdlibFunctions object at 0x1032149d0>

    @pytest.mark.asyncio
    async def test_collection_functions(self):
        """Test collection functions."""
        # length
        length_fn = registry.get("length")
        assert length_fn is not None
    
        # Test with string
>       result = await length_fn(Value(type_=CtyString(), value="hello"))
E       NameError: name 'Value' is not defined

tests/functions/test_stdlib.py:171: NameError
________________ TestCtyListAdvanced.test_validate_nested_lists ________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_advanced.TestCtyListAdvanced testMethod=test_validate_nested_lists>

    def test_validate_nested_lists(self):
        """Test validation of nested lists."""
        # Create a list of lists
        nested_list_type = CtyList(element_type=self.string_list)
        data = [["a", "b"], ["c", "d", "e"]]
    
        # Validate
        result = nested_list_type.validate(data)
    
        # Assertions
>       self.assertEqual(result, [["a", "b"], ["c", "d", "e"]])
E       AssertionError: Lists differ: [[CtyString(), CtyString()], [CtyString(), CtyString(), CtyString()]] != [['a', 'b'], ['c', 'd', 'e']]
E       
E       First differing element 0:
E       [CtyString(), CtyString()]
E       ['a', 'b']
E       
E       - [[CtyString(), CtyString()], [CtyString(), CtyString(), CtyString()]]
E       + [['a', 'b'], ['c', 'd', 'e']]

tests/list/test_list_advanced.py:83: AssertionError
_______________ TestCtyListAdvanced.test_validate_tuple_as_list ________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_advanced.TestCtyListAdvanced testMethod=test_validate_tuple_as_list>

    def test_validate_tuple_as_list(self):
        """Test that validate accepts tuples and converts them to lists."""
        # Create a tuple of strings
        data = ("apple", "banana", "cherry")
    
        # Validate
        result = self.string_list.validate(data)
    
        # Assertions
        self.assertIsInstance(result, list)
>       self.assertEqual(result, ["apple", "banana", "cherry"])
E       AssertionError: Lists differ: [CtyString(), CtyString(), CtyString()] != ['apple', 'banana', 'cherry']
E       
E       First differing element 0:
E       CtyString()
E       'apple'
E       
E       - [CtyString(), CtyString(), CtyString()]
E       + ['apple', 'banana', 'cherry']

tests/list/test_list_advanced.py:33: AssertionError
______________ TestCtyListAdvanced.test_validate_homogeneous_list ______________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_advanced.TestCtyListAdvanced testMethod=test_validate_homogeneous_list>

    def test_validate_homogeneous_list(self):
        """Test validation of a homogeneous list."""
        # Create a list of numbers
        data = [1, 2, 3, 4, 5]
    
        # Validate
        result = self.number_list.validate(data)
    
        # Assertions
>       self.assertEqual(result, [1, 2, 3, 4, 5])
E       AssertionError: Lists differ: [CtyNumber(), CtyNumber(), CtyNumber(), CtyNumber(), CtyNumber()] != [1, 2, 3, 4, 5]
E       
E       First differing element 0:
E       CtyNumber()
E       1
E       
E       - [CtyNumber(), CtyNumber(), CtyNumber(), CtyNumber(), CtyNumber()]
E       + [1, 2, 3, 4, 5]

tests/list/test_list_advanced.py:62: AssertionError
__________ TestCtyMsgpackIntegration.test_encode_decode_marked_values __________
[gw17] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x10ba46a50>

    @pytest.mark.asyncio
    async def test_encode_decode_marked_values(self):
        """Test encoding and decoding values with marks."""
        # Create string value with marks
        string_type = CtyString()
>       string_value = CtyValue(string_type, raw_value="Hello")
E       TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:441: TypeError
______________ TestCtyListAdvanced.test_element_at_negative_index ______________
[gw18] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_advanced.TestCtyListAdvanced testMethod=test_element_at_negative_index>

    def test_element_at_negative_index(self):
        """Test retrieving an element at a negative index."""
        # Create and validate a list
        data = ["apple", "banana", "cherry"]
        validated = self.string_list.validate(data)
    
        # Get element at negative index
        element = self.string_list.element_at(validated, -1)
    
        # Assertions
>       self.assertEqual(element, "cherry")
E       AssertionError: CtyString() != 'cherry'

tests/list/test_list_advanced.py:127: AssertionError
__________________ TestFunctionSystem.test_function_callable ___________________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <functions.test_function_base.TestFunctionSystem object at 0x108914050>

    @pytest.mark.asyncio
    async def test_function_callable(self):
        """Test Function object as a callable."""
        # Create a simple function to concatenate strings
>       def return_string(args: List[CtyValue]) -> CtyType:
E       NameError: name 'CtyType' is not defined

tests/functions/test_function_base.py:220: NameError
__________________________ test_create_object_helper ___________________________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_create_object_helper():
        """Test create_object helper function."""
        # Use helper function
>       obj = create_object(
            name=CtyString(),
            age=CtyNumber(),
            active=CtyBool(),
            optional=["age", "active"],
            sensitive=["active"]
        )
E       NameError: name 'create_object' is not defined

tests/object/test_cty_structural_object.py:603: NameError
__________ TestCtyListAdvanced.test_validate_heterogeneous_list_fails __________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_cty_collections_list_improve.TestCtyListAdvanced object at 0x11198c490>

    def test_validate_heterogeneous_list_fails(self):
        """Test validation fails for heterogeneous lists."""
        # Create a mixed list
        data = [1, "two", 3, True]
    
        # Validate against number list
>       with self.assertRaises(ValidationError):
E       AttributeError: 'TestCtyListAdvanced' object has no attribute 'assertRaises'

tests/list/test_cty_collections_list_improve.py:69: AttributeError
______________ TestCtyMsgpackIntegration.test_encode_decode_list _______________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <encoding.test_encoding_msgpack.TestCtyMsgpackIntegration object at 0x1142af360>

    @pytest.mark.asyncio
    async def test_encode_decode_list(self):
        """Test encoding and decoding list values."""
        # Create list values
        string_type = CtyString()
        list_type = CtyList(element_type=string_type)
    
        test_values = [
            [],
            ["one"],
            ["one", "two", "three"],
            ["", "empty", ""],
            ["special", "chars: !@#$"]
        ]
    
        for value in test_values:
            # Create Cty list value with string elements
            elements = [CtyValue(string_type, raw_value=item) for item in value]
>           cty_value = CtyValue(list_type, raw_value=elements)
E           TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

tests/encoding/test_encoding_msgpack.py:151: TypeError
_______________________ test_ctyobject_nested_validation _______________________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_ctyobject_nested_validation():
        """Test validation of nested objects."""
        # Setup nested object types
        address_type = CtyObject({
            "street": CtyString(),
            "city": CtyString(),
            "postal_code": CtyString()
        })
    
        user_type = CtyObject({
            "name": CtyString(),
            "address": address_type,
        })
    
        # Setup test data
        user_data = {
            "name": "John",
            "address": {
                "street": "123 Main St",
                "city": "Springfield",
                "postal_code": "12345"
            }
        }
    
        # Validate nested data
        validated = user_type.validate(user_data)
    
        # Verify deeply nested field
>       assert validated["address"]["city"] == "Springfield"
E       AssertionError: assert CtyString() == 'Springfield'

tests/object/test_cty_structural_object.py:98: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'name': 'John', 'address': {'street': '123 Main St', 'city': 'Springfield', 'postal_code': '12345'}}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'address', 'name'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute name with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute name: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute address with type object({city: CtyString, postal_code: CtyString, street: CtyString})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'street': '123 Main St', 'city': 'Springfield', 'postal_code': '12345'}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'postal_code', 'street', 'city'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute street with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute street: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute city with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute city: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute postal_code with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute postal_code: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'street': CtyString(), 'city': CtyString(), 'postal_code': CtyString()}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute address: {'street': CtyString(), 'city': CtyString(), 'postal_code': CtyString()}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'name': CtyString(), 'address': {'street': CtyString(), 'city': CtyString(), 'postal_code': CtyString()}}
_______________________ test_ctyobject_validate_success ________________________
[gw2] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_ctyobject_validate_success():
        """Test validation with valid attributes."""
        # Setup object type and sample data
        obj = CtyObject({
            "name": CtyString(),
            "age": CtyNumber(),
            "active": CtyBool()
        })
    
        valid_data = {
            "name": "John Doe",
            "age": 30,
            "active": True
        }
    
        # Execute validation
        validated = obj.validate(valid_data)
    
        # Verify results
>       assert validated == {"name": "John Doe", "age": 30, "active": True}
E       AssertionError: assert {'active': Ct...: CtyString()} == {'active': Tr...': 'John Doe'}
E         
E         Differing items:
E         {'active': CtyBool(value=True)} != {'active': True}
E         {'name': CtyString()} != {'name': 'John Doe'}
E         {'age': CtyNumber()} != {'age': 30}
E         
E         Full diff:...
E         
E         ...Full output truncated (8 lines hidden), use '-vv' to show

tests/object/test_cty_structural_object.py:33: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'name': 'John Doe', 'age': 30, 'active': True}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'active', 'age', 'name'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute name with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute name: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute age with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute age: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute active with type CtyBool
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute active: CtyBool
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'name': CtyString(), 'age': CtyNumber(), 'active': CtyBool(value=True)}
______________ TestMsgpackEncoding.test_decode_with_ext_hook_null ______________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

data = b'encoded data', type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
>               return CtyValue(type_, raw_value=str(raw_value))
E               TypeError: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:275: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x1169b9c50>

    @pytest.mark.asyncio
    async def test_decode_with_ext_hook_null(self):
        """Test decoding a null value using ext_hook."""
        type_ = CtyString()
    
        # Mock msgpack.unpackb to return a null value through ext_hook
        ext_hook = None
    
        def mock_unpackb(data, **kwargs):
            nonlocal ext_hook
            ext_hook = kwargs['ext_hook']
            # Create ExtType for null value
            from msgpack import ExtType
            return ext_hook(EXT_NULL, b"type data")
    
        with patch('msgpack.unpackb', mock_unpackb):
            # Decode value
>           result = await decode_value(b'encoded data', type_)

tests/encoding/test_encoding_msgpack_more.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'encoded data', type_ = CtyString(), options = None

    async def decode_value(data: bytes, type_: Union[CtyType, Type[CtyType]], options: Optional[Dict[str, Any]] = None) -> CtyValue:
        """
        Decode MessagePack data to a Cty value.
    
        Args:
            data: MessagePack encoded data
            type_: The Cty type to decode as
            options: Optional MessagePack decoding options
    
        Returns:
            CtyValue: The decoded Cty value
    
        Raises:
            MsgpackDecodeError: If decoding fails
        """
        logger.debug(f" Decoding MessagePack data to {type_.__class__.__name__}")
    
        # Merge with default options
        opts = {**DEFAULT_DECODE_OPTIONS}
        if options:
            opts.update(options)
    
        # Ensure we have a type instance, not a class
        if isinstance(type_, type) and issubclass(type_, CtyType):
            type_ = type_()
    
        # Custom extension type handler
        def ext_hook(code, data):
            if code == EXT_UNKNOWN:
                logger.debug(" Decoding unknown value")
                return CtyValue(type_, is_unknown=True)
    
            elif code == EXT_NULL:
                logger.debug(" Decoding null value")
                return CtyValue(type_, is_null=True)
    
            elif code == EXT_MARKED:
                logger.debug(" Decoding marked value")
                marked_data = msgpack.unpackb(data)
                inner_value = asyncio.run(decode_value(marked_data["value"], type_))
                for mark in marked_data["marks"]:
                    inner_value = inner_value.mark(mark)
                return inner_value
    
            # Return raw data for unknown extension types
            return ExtType(code, data)
    
        opts["ext_hook"] = ext_hook
    
        try:
            # Unpack data
            raw_value = msgpack.unpackb(data, **opts)
    
            # Special handling for set and tuple
            if isinstance(raw_value, dict):
                if raw_value.get("_cty_set"):
                    logger.debug(" Decoding set value")
                    elements = raw_value["elements"]
                    element_type = type_.element_type
                    set_values = set()
                    for element_data in elements:
                        element_val = await decode_value(element_data, element_type)
                        set_values.add(element_val)
                    return CtyValue(type_, raw_value=set_values)
    
                elif raw_value.get("_cty_tuple"):
                    logger.debug(" Decoding tuple value")
                    elements = raw_value["elements"]
                    tuple_types = type_.element_types
                    tuple_values = []
                    for i, element_data in enumerate(elements):
                        element_type = tuple_types[i] if i < len(tuple_types) else CtyDynamic()
                        element_val = await decode_value(element_data, element_type)
                        tuple_values.append(element_val)
                    return CtyValue(type_, raw_value=tuple(tuple_values))
    
            # Type-specific decoding
            type_name = type_.__class__.__name__
    
            # Primitive types
            if type_name == "CtyString":
                return CtyValue(type_, raw_value=str(raw_value))
    
            elif type_name == "CtyNumber":
                if isinstance(raw_value, int):
                    return CtyValue(type_, raw_value=Decimal(raw_value))
                return CtyValue(type_, raw_value=Decimal(str(raw_value)))
    
            elif type_name == "CtyBool":
                return CtyValue(type_, raw_value=bool(raw_value))
    
            # Collection types
            elif type_name == "CtyList":
                element_type = type_.element_type
                elements = []
                for element_data in raw_value:
                    element_val = await decode_value(msgpack.packb(element_data, **DEFAULT_ENCODE_OPTIONS), element_type)
                    elements.append(element_val)
                return CtyValue(type_, raw_value=elements)
    
            elif type_name == "CtyMap":
                key_type = type_.key_type
                value_type = type_.value_type
                items = {}
                for key_str, val_data in raw_value.items():
                    # MessagePack requires string keys
                    key_val = await decode_value(msgpack.packb(key_str, **DEFAULT_ENCODE_OPTIONS), key_type)
                    val_val = await decode_value(msgpack.packb(val_data, **DEFAULT_ENCODE_OPTIONS), value_type)
                    items[key_val] = val_val
                return CtyValue(type_, raw_value=items)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_data in raw_value.items():
                    attr_type = type_.attribute_types.get(attr_name, CtyDynamic())
                    attr_val = await decode_value(msgpack.packb(attr_data, **DEFAULT_ENCODE_OPTIONS), attr_type)
                    attributes[attr_name] = attr_val
                return CtyValue(type_, raw_value=attributes)
    
            # Dynamic - directly use the raw value
            elif type_name == "CtyDynamic":
                return CtyValue(type_, raw_value=raw_value)
    
            # Default handling
            return CtyValue(type_, raw_value=raw_value)
    
        except Exception as e:
            error_msg = f"Failed to decode MessagePack data: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackDecodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackDecodeError: Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'

src/pyvider/cty/encoding/msgpack.py:324: MsgpackDecodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding MessagePack data to CtyString
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Decoding null value
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to decode MessagePack data: CtyValue.__init__() got an unexpected keyword argument 'raw_value'
__________________ TestMsgpackEncoding.test_encode_null_value __________________
[gw19] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

value = <pyvider.cty.values.base.CtyValue object at 0x10d0947d0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
>               type_bytes = await encode_type(value.type)
E               TypeError: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:103: TypeError

The above exception was the direct cause of the following exception:

self = <encoding.test_encoding_msgpack_more.TestMsgpackEncoding object at 0x10d19e9f0>

    @pytest.mark.asyncio
    async def test_encode_null_value(self):
        """Test encoding a null value."""
        # Create a null value
        value = CtyValue(type_=CtyString(), is_null=True)
    
        # Mock msgpack.packb
        mock_packb = MagicMock(return_value=b'test packed data')
    
        # Mock encode_type
        mock_encode_type = MagicMock(return_value=b'type bytes')
    
        with patch('msgpack.packb', mock_packb), \
             patch('pyvider.cty.encoding.msgpack.encode_type', mock_encode_type):
            # Encode value
>           result = await encode_value(value)

tests/encoding/test_encoding_msgpack_more.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <pyvider.cty.values.base.CtyValue object at 0x10d0947d0>, options = None

    async def encode_value(value: CtyValue, options: Optional[Dict[str, Any]] = None) -> bytes:
        """
        Encode a Cty value to MessagePack format.
    
        Args:
            value: The Cty value to encode
            options: Optional MessagePack encoding options
    
        Returns:
            bytes: MessagePack encoded data
    
        Raises:
            MsgpackEncodeError: If encoding fails
        """
        logger.debug(f" Encoding Cty value to MessagePack: {value}")
    
        # Merge with default options
        opts = {**DEFAULT_ENCODE_OPTIONS}
        if options:
            opts.update(options)
    
        try:
            # Special handling for unknown and null values
            if not value.is_known:
                logger.debug(" Encoding unknown value")
                type_bytes = await encode_type(value.type)
                ext_data = msgpack.packb({
                    "type": type_bytes,
                    "path": []  # For future path support
                })
                return msgpack.packb(ExtType(EXT_UNKNOWN, ext_data), **opts)
    
            if value.is_null:
                logger.debug(" Encoding null value")
                type_bytes = await encode_type(value.type)
                return msgpack.packb(ExtType(EXT_NULL, type_bytes), **opts)
    
            # Handle marked values
            if value.marks:
                logger.debug(f" Encoding marked value with {len(value.marks)} marks")
                unmarked_value, marks = value.unmark()
                data = {
                    "value": await encode_value(unmarked_value),
                    "marks": [str(mark) for mark in marks]
                }
                return msgpack.packb(ExtType(EXT_MARKED, msgpack.packb(data)), **opts)
    
            # Type-specific encoding
            type_name = type(value.type).__name__
    
            # Primitive types
            if type_name == "CtyString":
                return msgpack.packb(value.raw_value, **opts)
    
            elif type_name == "CtyNumber":
                # Ensure numbers are encoded as ints when possible
                if isinstance(value.raw_value, Decimal):
                    if value.raw_value == value.raw_value.to_integral_value():
                        return msgpack.packb(int(value.raw_value), **opts)
                return msgpack.packb(float(value.raw_value), **opts)
    
            elif type_name == "CtyBool":
                return msgpack.packb(bool(value.raw_value), **opts)
    
            # Collection types
            elif type_name == "CtyList":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                return msgpack.packb(elements, **opts)
    
            elif type_name == "CtyMap":
                items = {}
                for key, val in value.raw_value.items():
                    key_str = str(key)  # Keys must be strings in MessagePack
                    val_data = await encode_value(val)
                    items[key_str] = val_data
                return msgpack.packb(items, **opts)
    
            elif type_name == "CtySet":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Sets are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_set": True,
                    "elements": elements
                }, **opts)
    
            # Structural types
            elif type_name == "CtyObject":
                attributes = {}
                for attr_name, attr_val in value.raw_value.items():
                    attr_data = await encode_value(attr_val)
                    attributes[attr_name] = attr_data
                return msgpack.packb(attributes, **opts)
    
            elif type_name == "CtyTuple":
                elements = []
                for element in value.raw_value:
                    element_data = await encode_value(element)
                    elements.append(element_data)
                # Tuples are encoded as arrays with special marker
                return msgpack.packb({
                    "_cty_tuple": True,
                    "elements": elements
                }, **opts)
    
            # Dynamic values - let MessagePack determine format
            elif type_name == "CtyDynamic":
                return msgpack.packb(value.raw_value, **opts)
    
            # Unknown type
            else:
                logger.warning(f" Unknown Cty type: {type_name}, using default encoding")
                return msgpack.packb(value.raw_value, **opts)
    
        except Exception as e:
            error_msg = f"Failed to encode Cty value: {e}"
            logger.error(f" {error_msg}", exc_info=True)
>           raise MsgpackEncodeError(error_msg) from e
E           pyvider.cty.encoding.msgpack.MsgpackEncodeError: Failed to encode Cty value: object bytes can't be used in 'await' expression

src/pyvider/cty/encoding/msgpack.py:191: MsgpackEncodeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding Cty value to MessagePack: <pyvider.cty.values.base.CtyValue object at 0x10d0947d0>
2025-03-12 17:00:12    [DEBUG]    cty.encoding.msgpack   |  Encoding null value
2025-03-12 17:00:12    [ERROR]    cty.encoding.msgpack   |  Failed to encode Cty value: object bytes can't be used in 'await' expression
_______________ TestCtyObjectIntegration.test_validation_success _______________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <object.test_object.TestCtyObjectIntegration object at 0x10898d040>

    @pytest.mark.asyncio
    async def test_validation_success(self):
        """Test successful validation of object values."""
        # Create object type
        person_type = CtyObject(
            attribute_types={
                "name": CtyString(),
                "age": CtyNumber(),
                "active": CtyBool(),
            }
        )
    
        # Valid values
        valid_values = [
            {
                "name": "Alice",
                "age": 30,
                "active": True,
            },
            {
                "name": "Bob",
                "age": Decimal("25.5"),
                "active": False,
            },
            {
                "name": "",
                "age": 0,
                "active": False,
            },
        ]
    
        # Validate each value
        for value in valid_values:
            validated = person_type.validate(value)
            assert validated is not None
            assert isinstance(validated, dict)
            assert "name" in validated
            assert "age" in validated
            assert "active" in validated
    
            # Check types
>           assert isinstance(validated["name"], str)
E           assert False
E            +  where False = isinstance(CtyString(), str)

tests/object/test_object.py:198: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'name': 'Alice', 'age': 30, 'active': True}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'age', 'name', 'active'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute name with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute name: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute age with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute age: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute active with type CtyBool
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute active: CtyBool
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'name': CtyString(), 'age': CtyNumber(), 'active': CtyBool(value=True)}
_____________ TestCtyObjectIntegration.test_complex_nested_object ______________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <object.test_object.TestCtyObjectIntegration object at 0x1077db8e0>

    @pytest.mark.asyncio
    async def test_complex_nested_object(self):
        """Test complex nested object type."""
        # Create complex nested object type
        server_type = CtyObject(
            attribute_types={
                "name": CtyString(),
                "size": CtyString(),
                "network": CtyObject(
                    attribute_types={
                        "subnet": CtyString(),
                        "vpc_id": CtyString(),
                        "security_groups": CtyList(element_type=CtyString()),
                    },
                    optional_attributes=frozenset(["security_groups"])
                ),
                "disks": CtyList(
                    element_type=CtyObject(
                        attribute_types={
                            "size_gb": CtyNumber(),
                            "type": CtyString(),
                            "iops": CtyNumber(),
                        },
                        optional_attributes=frozenset(["iops"])
                    )
                ),
                "tags": CtyMap(
                    key_type=CtyString(),
                    value_type=CtyString()
                )
            },
            optional_attributes=frozenset(["tags"]),
            block_attributes=frozenset(["network", "disks"])
        )
    
        # Create valid complex value
        value = {
            "name": "web-server",
            "size": "t3.large",
            "network": {
                "subnet": "subnet-123456",
                "vpc_id": "vpc-123456",
                "security_groups": ["sg-1", "sg-2"]
            },
            "disks": [
                {
                    "size_gb": 100,
                    "type": "gp3",
                    "iops": 3000
                },
                {
                    "size_gb": 500,
                    "type": "io2"
                }
            ],
            "tags": {
                "Environment": "production",
                "Owner": "devops"
            }
        }
    
        # Validate
        validated = server_type.validate(value)
        assert validated is not None
        assert isinstance(validated, dict)
    
        # Check top-level attributes
>       assert validated["name"] == "web-server"
E       AssertionError: assert CtyString() == 'web-server'

tests/object/test_object.py:857: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'name': 'web-server', 'size': 't3.large', 'network': {'subnet': 'subnet-123456', 'vpc_id': 'vpc-123456', 'security_groups': ['sg-1', 'sg-2']}, 'disks': [{'size_gb': 100, 'type': 'gp3', 'iops': 3000}, {'size_gb': 500, 'type': 'io2'}], 'tags': {'Environment': 'production', 'Owner': 'devops'}}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'size', 'network', 'disks', 'name'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute name with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute name: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute size with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute size: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute network with type object({security_groups: list(CtyString) (optional), subnet: CtyString, vpc_id: CtyString})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'subnet': 'subnet-123456', 'vpc_id': 'vpc-123456', 'security_groups': ['sg-1', 'sg-2']}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'vpc_id', 'subnet'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute subnet with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute subnet: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute vpc_id with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute vpc_id: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute security_groups with type list(CtyString)
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute security_groups: [CtyString(), CtyString()]
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'subnet': CtyString(), 'vpc_id': CtyString(), 'security_groups': [CtyString(), CtyString()]}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute network: {'subnet': CtyString(), 'vpc_id': CtyString(), 'security_groups': [CtyString(), CtyString()]}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute disks with type list(object({iops: CtyNumber (optional), size_gb: CtyNumber, type: CtyString}))
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'size_gb': 100, 'type': 'gp3', 'iops': 3000}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'size_gb', 'type'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute size_gb with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute size_gb: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute type with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute type: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute iops with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute iops: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': CtyNumber()}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'size_gb': 500, 'type': 'io2'}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'size_gb', 'type'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute size_gb with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute size_gb: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute type with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute type: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute iops with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Attribute iops is optional/computed and not provided
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': None}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute disks: [{'size_gb': CtyNumber(), 'type': CtyString(), 'iops': CtyNumber()}, {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': None}]
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute tags with type CtyMap
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute tags: {'Environment': 'production', 'Owner': 'devops'}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'name': CtyString(), 'size': CtyString(), 'network': {'subnet': CtyString(), 'vpc_id': CtyString(), 'security_groups': [CtyString(), CtyString()]}, 'disks': [{'size_gb': CtyNumber(), 'type': CtyString(), 'iops': CtyNumber()}, {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': None}], 'tags': {'Environment': 'production', 'Owner': 'devops'}}
______________ TestConvertFunctions.test_convert_unsafe_function _______________
[gw6] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x1087f16e0>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'convert' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConvertFunctions object at 0x1085cec10>

    @pytest.mark.asyncio
    async def test_convert_unsafe_function(self):
        """Test the convert_unsafe function."""
        # Mock registry.convert
        mock_result = CtyValue(CtyNumber(), 123)
        mock_convert = MagicMock(return_value=mock_result)
    
>       with patch('pyvider.cty.convert.convert.registry.convert', mock_convert):

tests/conversions/test_convert_2.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x1087f16e0>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'convert' is read-only"), <traceback object at 0x108791700>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'convert' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
______ TestCtyObjectIntegration.test_validation_with_optional_attributes _______
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <object.test_object.TestCtyObjectIntegration object at 0x10898d150>

    @pytest.mark.asyncio
    async def test_validation_with_optional_attributes(self):
        """Test validation with optional attributes."""
        # Create object type with optional attributes
        person_type = CtyObject(
            attribute_types={
                "name": CtyString(),
                "age": CtyNumber(),
                "active": CtyBool(),
            },
            optional_attributes=frozenset(["age", "active"])
        )
    
        # Value missing optional attributes
        value = {
            "name": "Alice",
        }
    
        # Validate
        validated = person_type.validate(value)
        assert validated is not None
        assert isinstance(validated, dict)
        assert "name" in validated
>       assert validated["name"] == "Alice"
E       AssertionError: assert CtyString() == 'Alice'

tests/object/test_object.py:225: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'name': 'Alice'}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'name'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute name with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute name: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute age with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Attribute age is optional/computed and not provided
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute active with type CtyBool
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Attribute active is optional/computed and not provided
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'name': CtyString(), 'age': None, 'active': None}
________________________ TestPathSystem.test_key_paths _________________________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <path.test_path.TestPathSystem object at 0x105315f30>

    @pytest.mark.asyncio
    async def test_key_paths(self):
        """Test paths with key access."""
        # Create a map type
        scores_type = CtyMap(key_type=CtyString(), value_type=CtyNumber())
    
        # Create a map value
        scores = CtyValue(type_=scores_type, value={
            "Alice": 95,
            "Bob": 87,
            "Charlie": 92,
            "Dave": 78
        })
    
        # Test key access
        bob_path = Path.key("Bob")
>       bob_result = await bob_path.apply_path(scores)

tests/path/test_path.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/pyvider/cty/path/path.py:404: in apply_path
    current = await step.apply(current)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KeyStep(key='Bob')
value = <pyvider.cty.values.base.CtyValue object at 0x10509d220>

    async def apply(self, value: Value) -> Value:
        """
        Get the value associated with the given key from a map value.
    
        Args:
            value: The map value
    
        Returns:
            Value: The associated value
    
        Raises:
            AttributePathError: If the value is not a map or has no such key
        """
        logger.debug(f" Getting value for key {self.key} from map")
    
        if value.is_null:
            raise AttributePathError(f"Cannot get key from null value")
    
>       if value.is_unknown:
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

src/pyvider/cty/path/path.py:274: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Applying path ['Bob'] to value
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Getting value for key Bob from map
___________________ TestConvertFunctions.test_unify_function ___________________
[gw7] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x104ff1a70>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'unify' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConvertFunctions object at 0x104d05bf0>

    @pytest.mark.asyncio
    async def test_unify_function(self):
        """Test the unify function."""
        # Mock registry.unify
        mock_result = (CtyBool, [MagicMock(), MagicMock()])
        mock_unify = MagicMock(return_value=mock_result)
    
>       with patch('pyvider.cty.convert.convert.registry.unify', mock_unify):

tests/conversions/test_convert_2.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x104ff1a70>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'unify' is read-only"), <traceback object at 0x104fb8440>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'unify' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
___________________ test_ctyobject_invalid_constructor_types ___________________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_ctyobject_invalid_constructor_types():
        """Test error when attribute_types is not a dict."""
        # Pass invalid attribute_types (not a dict)
>       with pytest.raises(InvalidTypeError):
E       NameError: name 'InvalidTypeError' is not defined

tests/object/test_cty_structural_object.py:564: NameError
_________ TestDynamicPseudoType.test_dynamic_type_init_with_validators _________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x114316520>

    def test_dynamic_type_init_with_validators(self):
        """Test DynamicPseudoType initialization with validators."""
        # Create mock validators
        validator1 = MagicMock()
        validator2 = MagicMock()
        validators = (validator1, validator2)
    
        # Create a dynamic type with validators
        dynamic = DynamicPseudoType(validators=validators)
    
        # Assertions
>       self.assertEqual(dynamic.validators, validators)
E       AttributeError: 'TestDynamicPseudoType' object has no attribute 'assertEqual'

tests/types/test_cty_type.py:48: AttributeError
_____________________ TestPathSystem.test_attribute_paths ______________________
[gw20] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <path.test_path.TestPathSystem object at 0x113f525d0>

    @pytest.mark.asyncio
    async def test_attribute_paths(self):
        """Test paths with attribute access."""
        # Create an object type
        person_type = CtyObject(attribute_types={
            "name": CtyString(),
            "age": CtyNumber(),
            "address": CtyObject(attribute_types={
                "street": CtyString(),
                "city": CtyString(),
                "zip": CtyString()
            })
        })
    
        # Create an object value
        person = CtyValue(type_=person_type, value={
            "name": "Alice",
            "age": 30,
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "zip": "12345"
            }
        })
    
        # Test direct attribute access
        name_path = Path.get_attr("name")
>       name_result = await name_path.apply_path(person)

tests/path/test_path.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/pyvider/cty/path/path.py:404: in apply_path
    current = await step.apply(current)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = GetAttrStep(name='name')
value = <pyvider.cty.values.base.CtyValue object at 0x113cc5310>

    async def apply(self, value: Value) -> Value:
        """
        Get the attribute with the given name from an object value.
    
        Args:
            value: The object value
    
        Returns:
            Value: The attribute value
    
        Raises:
            AttributePathError: If the value is not an object or has no such attribute
        """
        logger.debug(f" Getting attribute {self.name} from object")
    
        if value.is_null:
            raise AttributePathError(f"Cannot get attribute from null value")
    
>       if value.is_unknown:
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

src/pyvider/cty/path/path.py:111: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Applying path .name to value
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Getting attribute name from object
__________________________ test_ctyobject_with_blocks __________________________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_ctyobject_with_blocks():
        """Test object with block attributes."""
        # Setup object with block attribute
        block_type = CtyObject({
            "id": CtyString(),
            "enabled": CtyBool()
        })
    
        parent = CtyObject({
            "config": block_type,
            "metadata": CtyString(),
        }, block_attributes=frozenset(["config"]))
    
        # Setup data
        data = {
            "config": {
                "id": "123",
                "enabled": True
            },
            "metadata": "meta"
        }
    
        # Validate data
        validated = parent.validate(data)
    
        # Verify block attribute
>       assert validated["config"]["enabled"] is True
E       assert CtyBool(value=True) is True

tests/object/test_cty_structural_object.py:247: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'config': {'id': '123', 'enabled': True}, 'metadata': 'meta'}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'config', 'metadata'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute config with type object({enabled: CtyBool, id: CtyString})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'id': '123', 'enabled': True}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'enabled', 'id'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute id with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute id: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute enabled with type CtyBool
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute enabled: CtyBool
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'id': CtyString(), 'enabled': CtyBool(value=True)}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute config: {'id': CtyString(), 'enabled': CtyBool(value=True)}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute metadata with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute metadata: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'config': {'id': CtyString(), 'enabled': CtyBool(value=True)}, 'metadata': CtyString()}
_______ TestDynamicPseudoType.test_dynamic_type_validate_with_validators _______
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x1050d1b50>

    def test_dynamic_type_validate_with_validators(self):
        """Test DynamicPseudoType.validate with validators."""
        # Create a dynamic type with a validator
        validator = MagicMock()
        dynamic = DynamicPseudoType(validators=(validator,))
    
        # Patch the _run_validators method
>       dynamic._run_validators = MagicMock()
E       AttributeError: 'DynamicPseudoType' object has no attribute '_run_validators' and no __dict__ for setting new attributes

tests/types/test_cty_type.py:77: AttributeError
__________________________ test_complex_nested_object __________________________
[gw17] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    def test_complex_nested_object():
        """Test validation of a complex nested object."""
        # Create complex nested object type
        server_type = CtyObject(
            attribute_types={
                "name": CtyString(),
                "size": CtyString(),
                "network": CtyObject(
                    attribute_types={
                        "subnet": CtyString(),
                        "vpc_id": CtyString(),
                        "security_groups": CtyList(element_type=CtyString()),
                    }
                ),
                "disks": CtyList(
                    element_type=CtyObject(
                        attribute_types={
                            "size_gb": CtyNumber(),
                            "type": CtyString(),
                            "iops": CtyNumber(),
                        },
                        optional_attributes=frozenset(["iops"])
                    )
                ),
                "tags": CtyObject(
                    attribute_types={
                        "environment": CtyString(),
                        "owner": CtyString()
                    },
                    optional_attributes=frozenset(["owner"])
                )
            },
            optional_attributes=frozenset(["tags"]),
            block_attributes=frozenset(["network", "disks"])
        )
    
        # Create valid complex value
        value = {
            "name": "web-server",
            "size": "t3.large",
            "network": {
                "subnet": "subnet-123456",
                "vpc_id": "vpc-123456",
                "security_groups": ["sg-1", "sg-2"]
            },
            "disks": [
                {
                    "size_gb": 100,
                    "type": "gp3",
                    "iops": 3000
                },
                {
                    "size_gb": 500,
                    "type": "io2"
                }
            ],
            "tags": {
                "environment": "production",
                "owner": "devops"
            }
        }
    
        # Validate
        validated = server_type.validate(value)
    
        # Check various aspects of the validated object
>       assert validated["name"] == "web-server"
E       AssertionError: assert CtyString() == 'web-server'

tests/object/test_cty_structural_object.py:770: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'name': 'web-server', 'size': 't3.large', 'network': {'subnet': 'subnet-123456', 'vpc_id': 'vpc-123456', 'security_groups': ['sg-1', 'sg-2']}, 'disks': [{'size_gb': 100, 'type': 'gp3', 'iops': 3000}, {'size_gb': 500, 'type': 'io2'}], 'tags': {'environment': 'production', 'owner': 'devops'}}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'name', 'size', 'disks', 'network'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute name with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute name: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute size with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute size: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute network with type object({security_groups: list(CtyString), subnet: CtyString, vpc_id: CtyString})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'subnet': 'subnet-123456', 'vpc_id': 'vpc-123456', 'security_groups': ['sg-1', 'sg-2']}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'vpc_id', 'security_groups', 'subnet'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute subnet with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute subnet: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute vpc_id with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute vpc_id: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute security_groups with type list(CtyString)
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute security_groups: [CtyString(), CtyString()]
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'subnet': CtyString(), 'vpc_id': CtyString(), 'security_groups': [CtyString(), CtyString()]}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute network: {'subnet': CtyString(), 'vpc_id': CtyString(), 'security_groups': [CtyString(), CtyString()]}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute disks with type list(object({iops: CtyNumber (optional), size_gb: CtyNumber, type: CtyString}))
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'size_gb': 100, 'type': 'gp3', 'iops': 3000}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'type', 'size_gb'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute size_gb with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute size_gb: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute type with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute type: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute iops with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute iops: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': CtyNumber()}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'size_gb': 500, 'type': 'io2'}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'type', 'size_gb'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute size_gb with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute size_gb: CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute type with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute type: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute iops with type CtyNumber
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Attribute iops is optional/computed and not provided
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': None}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute disks: [{'size_gb': CtyNumber(), 'type': CtyString(), 'iops': CtyNumber()}, {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': None}]
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute tags with type object({environment: CtyString, owner: CtyString (optional)})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating value against CtyObject: {'environment': 'production', 'owner': 'devops'}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Required attributes: frozenset({'environment'})
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute environment with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute environment: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating attribute owner with type CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute owner: CtyString
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'environment': CtyString(), 'owner': CtyString()}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validated attribute tags: {'environment': CtyString(), 'owner': CtyString()}
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Successfully validated object: {'name': CtyString(), 'size': CtyString(), 'network': {'subnet': CtyString(), 'vpc_id': CtyString(), 'security_groups': [CtyString(), CtyString()]}, 'disks': [{'size_gb': CtyNumber(), 'type': CtyString(), 'iops': CtyNumber()}, {'size_gb': CtyNumber(), 'type': CtyString(), 'iops': None}], 'tags': {'environment': CtyString(), 'owner': CtyString()}}
______________ TestDynamicPseudoType.test_dynamic_type_usable_as _______________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x106e8e250>

    def test_dynamic_type_usable_as(self):
        """Test DynamicPseudoType.usable_as method."""
        # Dynamic type should be usable as any other type
>       self.assertTrue(self.dynamic_type.usable_as(self.other_type))
E       AttributeError: 'TestDynamicPseudoType' object has no attribute 'assertTrue'

tests/types/test_cty_type.py:98: AttributeError
_______________ TestCtyListWithNestedTypes.test_complex_nesting ________________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <list.test_list_with_nested_types.TestCtyListWithNestedTypes testMethod=test_complex_nesting>

    def test_complex_nesting(self):
        """Test complex nested list structures."""
        # Create a complex nested structure: List of List of List of Number
        inner_list = CtyList(element_type=CtyNumber())
        middle_list = CtyList(element_type=inner_list)
        outer_list = CtyList(element_type=middle_list)
    
        # Create test data
        data = [
            [[1, 2], [3, 4]],
            [[5, 6, 7]],
            []
        ]
    
        # Validate
        result = outer_list.validate(data)
    
        # Assertions
>       self.assertEqual(result, data)
E       AssertionError: Lists differ: [[[CtyNumber(), CtyNumber()], [CtyNumber(), [56 chars], []] != [[[1, 2], [3, 4]], [[5, 6, 7]], []]
E       
E       First differing element 0:
E       [[CtyNumber(), CtyNumber()], [CtyNumber(), CtyNumber()]]
E       [[1, 2], [3, 4]]
E       
E       + [[[1, 2], [3, 4]], [[5, 6, 7]], []]
E       - [[[CtyNumber(), CtyNumber()], [CtyNumber(), CtyNumber()]],
E       -  [[CtyNumber(), CtyNumber(), CtyNumber()]],
E       -  []]

tests/list/test_list_with_nested_types.py:103: AssertionError
_________________ TestDynamicPseudoType.test_dynamic_type_init _________________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x1119d6fd0>

    def test_dynamic_type_init(self):
        """Test DynamicPseudoType initialization."""
        # Create a dynamic type
        dynamic = DynamicPseudoType()
    
        # Assertions
>       self.assertEqual(dynamic.metadata, ())
E       AttributeError: 'TestDynamicPseudoType' object has no attribute 'assertEqual'

tests/types/test_cty_type.py:24: AttributeError
________________________ TestValue.test_value_add_mark _________________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_base.TestValue testMethod=test_value_add_mark>

    def test_value_add_mark(self):
        """Test mark method to add a mark."""
        # Create a value without marks
        val = CtyValue(type_=self.mock_type, value="test")
    
        # Add a mark
>       marked_val = val.mark(self.mock_mark)

tests/values/test_values_base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyvider.cty.values.base.CtyValue object at 0x104550c20>
mark = 'sensitive'

    def mark(self, mark: Any) -> "Value[T]":
        """Add a mark to this value."""
>       return Value(
            type_=self._type,
            value=self._value,
            is_unknown=self._is_unknown,
            is_null=self._is_null,
            marks=frozenset(self._marks.union({mark}))
        )
E       NameError: name 'Value' is not defined

src/pyvider/cty/values/base.py:46: NameError
______________________ TestPathSystem.test_complex_paths _______________________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <path.test_path.TestPathSystem object at 0x105316190>

    @pytest.mark.asyncio
    async def test_complex_paths(self):
        """Test complex paths with multiple step types."""
        # Create a complex nested structure
        # List of users, each with a name and a map of scores
        user_type = CtyObject(attribute_types={
            "name": CtyString(),
            "scores": CtyMap(key_type=CtyString(), value_type=CtyNumber())
        })
        users_type = CtyList(element_type=user_type)
    
        users = CtyValue(type_=users_type, value=[
            {
                "name": "Alice",
                "scores": {
                    "math": 95,
                    "science": 92,
                    "history": 88
                }
            },
            {
                "name": "Bob",
                "scores": {
                    "math": 87,
                    "science": 85,
                    "history": 92
                }
            },
            {
                "name": "Charlie",
                "scores": {
                    "math": 78,
                    "science": 90,
                    "history": 85
                }
            }
        ])
    
        # Test complex path: second user's math score
        # users[1].scores["math"]
        path = Path.index(1).child("scores").key_step("math")
>       result = await path.apply_path(users)

tests/path/test_path.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/pyvider/cty/path/path.py:404: in apply_path
    current = await step.apply(current)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = IndexStep(index=1)
value = <pyvider.cty.values.base.CtyValue object at 0x10509df30>

    async def apply(self, value: Value) -> Value:
        """
        Get the element at the given index from a list or tuple value.
    
        Args:
            value: The list or tuple value
    
        Returns:
            Value: The element value
    
        Raises:
            AttributePathError: If the value is not a list or tuple, or the index is out of bounds
        """
        logger.debug(f" Getting element at index {self.index} from collection")
    
        if value.is_null:
            raise AttributePathError(f"Cannot index into null value")
    
>       if value.is_unknown:
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

src/pyvider/cty/path/path.py:191: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Applying path [1].scores['math'] to value
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Getting element at index 1 from collection
_____________ TestConversionRegistry.test_registry_convert_no_path _____________
[gw5] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x105c00d60>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConversionRegistry object at 0x105997b60>

    @pytest.mark.asyncio
    async def test_registry_convert_no_path(self):
        """Test converting a value with no path."""
        # Mock the find_conversion_path method to return None
>       with patch.object(registry, 'find_conversion_path', return_value=None):

tests/conversions/test_convert_2.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x105c00d60>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'find_conversion_path' is read-only"), <traceback object at 0x105f9f940>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
_________________________ TestValue.test_value_unmark __________________________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_base.TestValue testMethod=test_value_unmark>

    def test_value_unmark(self):
        """Test unmark method to remove all marks."""
        # Create a value with marks
        val = CtyValue(
            type_=self.mock_type,
            value="test",
            marks=frozenset(["mark1", "mark2"])
        )
    
        # Remove all marks
>       unmarked_val, removed_marks = val.unmark()

tests/values/test_values_base.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyvider.cty.values.base.CtyValue object at 0x1050fc2d0>

    def unmark(self) -> tuple["Value[T]", FrozenSet]:
        """Remove all marks from this value and return them."""
>       return Value(
            type_=self._type,
            value=self._value,
            is_unknown=self._is_unknown,
            is_null=self._is_null,
            marks=frozenset()
        ), self._marks
E       NameError: name 'Value' is not defined

src/pyvider/cty/values/base.py:56: NameError
_______________ TestDynamicPseudoType.test_dynamic_type_validate _______________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x114316650>

    def test_dynamic_type_validate(self):
        """Test DynamicPseudoType.validate method."""
        # Test with various value types
        values = [
            "string",
            123,
            True,
            {"key": "value"},
            [1, 2, 3],
            None
        ]
    
        for value in values:
            # Dynamic type should accept any value
>           result = self.dynamic_type.validate(value)
E           AttributeError: 'TestDynamicPseudoType' object has no attribute 'dynamic_type'

tests/types/test_cty_type.py:65: AttributeError
________________ TestDynamicPseudoType.test_dynamic_type_equal _________________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x103f96140>

    def test_dynamic_type_equal(self):
        """Test DynamicPseudoType.equal method."""
        # Create another dynamic type
        another_dynamic = DynamicPseudoType()
    
        # Assertions - dynamic types should be equal to each other
>       self.assertTrue(self.dynamic_type.equal(another_dynamic))
E       AttributeError: 'TestDynamicPseudoType' object has no attribute 'assertTrue'

tests/types/test_cty_type.py:92: AttributeError
________ TestDynamicPseudoType.test_dynamic_type_string_representation _________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x106f28a50>

    def test_dynamic_type_string_representation(self):
        """Test string representation of DynamicPseudoType."""
        # Assertions
>       self.assertEqual(str(self.dynamic_type), "DynamicPseudoType")
E       AttributeError: 'TestDynamicPseudoType' object has no attribute 'assertEqual'

tests/types/test_cty_type.py:107: AttributeError
_______________________ TestPathSystem.test_index_paths ________________________
[gw20] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <path.test_path.TestPathSystem object at 0x113f52350>

    @pytest.mark.asyncio
    async def test_index_paths(self):
        """Test paths with index access."""
        # Create a list type
        numbers_type = CtyList(element_type=CtyNumber())
    
        # Create a list value
        numbers = CtyValue(type_=numbers_type, value=[10, 20, 30, 40, 50])
    
        # Test index access
        second_path = Path.index(1)
>       second_result = await second_path.apply_path(numbers)

tests/path/test_path.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/pyvider/cty/path/path.py:404: in apply_path
    current = await step.apply(current)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = IndexStep(index=1)
value = <pyvider.cty.values.base.CtyValue object at 0x113cc4910>

    async def apply(self, value: Value) -> Value:
        """
        Get the element at the given index from a list or tuple value.
    
        Args:
            value: The list or tuple value
    
        Returns:
            Value: The element value
    
        Raises:
            AttributePathError: If the value is not a list or tuple, or the index is out of bounds
        """
        logger.debug(f" Getting element at index {self.index} from collection")
    
        if value.is_null:
            raise AttributePathError(f"Cannot index into null value")
    
>       if value.is_unknown:
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

src/pyvider/cty/path/path.py:191: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Applying path [1] to value
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Getting element at index 1 from collection
__________ TestDynamicPseudoType.test_dynamic_type_init_with_metadata __________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_cty_type.TestDynamicPseudoType object at 0x1119d7110>

    def test_dynamic_type_init_with_metadata(self):
        """Test DynamicPseudoType initialization with metadata."""
        # Create a dynamic type with metadata
        metadata = ("description", "purpose")
        dynamic = DynamicPseudoType(metadata=metadata)
    
        # Assertions
>       self.assertEqual(dynamic.metadata, metadata)
E       AttributeError: 'TestDynamicPseudoType' object has no attribute 'assertEqual'

tests/types/test_cty_type.py:34: AttributeError
___________________ TestValue.test_value_add_multiple_marks ____________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_base.TestValue testMethod=test_value_add_multiple_marks>

    def test_value_add_multiple_marks(self):
        """Test adding multiple marks to a value."""
        # Create a value with one mark
        val = CtyValue(type_=self.mock_type, value="test", marks=frozenset(["mark1"]))
    
        # Add another mark
>       marked_val = val.mark("mark2")

tests/values/test_values_base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyvider.cty.values.base.CtyValue object at 0x105997ed0>, mark = 'mark2'

    def mark(self, mark: Any) -> "Value[T]":
        """Add a mark to this value."""
>       return Value(
            type_=self._type,
            value=self._value,
            is_unknown=self._is_unknown,
            is_null=self._is_null,
            marks=frozenset(self._marks.union({mark}))
        )
E       NameError: name 'Value' is not defined

src/pyvider/cty/values/base.py:46: NameError
__________________ TestConversionRegistry.test_registry_unify __________________
[gw5] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_2.TestConversionRegistry object at 0x105997c50>

    @pytest.mark.asyncio
    async def test_registry_unify(self):
        """Test unifying types."""
        # Register conversions
        converter = MagicMock()
        registry.register(
            source_type=CtyString,
            target_type=CtyBool,
            converter=converter,
            is_safe=True
        )
        registry.register(
            source_type=CtyNumber,
            target_type=CtyBool,
            converter=converter,
            is_safe=True
        )
    
        # Unify types
        result = registry.unify([CtyString, CtyNumber], allow_unsafe=False)
    
        # Verify result
>       assert result is not None
E       assert None is not None

tests/conversions/test_convert_2.py:313: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Registering conversion from CtyString to CtyBool (safe=True)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Registering conversion from CtyNumber to CtyBool (safe=True)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Attempting to unify 2 types
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyNumber to CtyString (unsafe=False)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  No conversion path found from CtyNumber to CtyString
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyString to CtyNumber (unsafe=False)
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  No conversion path found from CtyString to CtyNumber
2025-03-12 17:00:12    [DEBUG]     cty.convert.convert   |  Unable to unify types
________________ TestPathSystem.test_null_and_unknown_handling _________________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <path.test_path.TestPathSystem object at 0x1054dc5f0>

    @pytest.mark.asyncio
    async def test_null_and_unknown_handling(self):
        """Test paths with null and unknown values."""
        # Create an object type
        person_type = CtyObject(attribute_types={
            "name": CtyString(),
            "age": CtyNumber()
        })
    
        # Create a null value
        null_person = CtyValue(type_=person_type, is_null=True)
    
        # Path to attribute should fail for null
        name_path = Path.get_attr("name")
        with pytest.raises(AttributePathError):
            await name_path.apply_path(null_person)
    
        # Create an unknown value
        unknown_person = CtyValue(type_=person_type, is_unknown=True)
    
        # Path to attribute should return unknown value of correct type
>       name_result = await name_path.apply_path(unknown_person)

tests/path/test_path.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/pyvider/cty/path/path.py:404: in apply_path
    current = await step.apply(current)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = GetAttrStep(name='name')
value = <pyvider.cty.values.base.CtyValue object at 0x10509e2c0>

    async def apply(self, value: Value) -> Value:
        """
        Get the attribute with the given name from an object value.
    
        Args:
            value: The object value
    
        Returns:
            Value: The attribute value
    
        Raises:
            AttributePathError: If the value is not an object or has no such attribute
        """
        logger.debug(f" Getting attribute {self.name} from object")
    
        if value.is_null:
            raise AttributePathError(f"Cannot get attribute from null value")
    
>       if value.is_unknown:
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

src/pyvider/cty/path/path.py:111: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:12    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Applying path .name to value
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Getting attribute name from object
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Applying path .name to value
2025-03-12 17:00:12    [DEBUG]           cty.path.path   |  Getting attribute name from object
_______________________________ test_get_element _______________________________
[gw19] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    @pytest.mark.asyncio
    async def test_get_element():
        """Test get_element operation."""
        # List element access
        list_val = CtyValue(CtyList(element_type=CtyString()), ["a", "b", "c"])
    
        result = get_element(list_val, CtyValue(CtyNumber(), 0))
        assert result.is_known
        assert not result.is_null
        assert isinstance(result.type, CtyString)
        assert result.value == "a"
    
        result = get_element(list_val, CtyValue(CtyNumber(), 2))
        assert result.is_known
        assert not result.is_null
        assert result.value == "c"
    
        # Index out of range
        with pytest.raises(IndexError):
            get_element(list_val, CtyValue(CtyNumber(), 3))
    
        with pytest.raises(IndexError):
            get_element(list_val, CtyValue(CtyNumber(), -1))
    
        # Map element access
>       map_val = CtyValue(CtyMap(element_type=CtyNumber()), {"a": 1, "b": 2, "c": 3})
E       TypeError: CtyMap.__init__() got an unexpected keyword argument 'element_type'

tests/values/test_values_operations.py:659: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x10d0956d0> from <pyvider.cty.values.base.CtyValue object at 0x10d323890>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Got list element: a
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x10d0956d0> from <pyvider.cty.values.base.CtyValue object at 0x10d323890>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Got list element: c
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x10d0956d0> from <pyvider.cty.values.base.CtyValue object at 0x10d323890>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x10d0956d0> from <pyvider.cty.values.base.CtyValue object at 0x10d323890>
_____________________________ test_equals_complex ______________________________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    @pytest.mark.asyncio
    async def test_equals_complex():
        """Test equality for complex types."""
        # List equality
        list1 = CtyValue(CtyList(element_type=CtyString()), ["a", "b", "c"])
        list2 = CtyValue(CtyList(element_type=CtyString()), ["a", "b", "c"])
        list3 = CtyValue(CtyList(element_type=CtyString()), ["a", "b", "d"])
        list4 = CtyValue(CtyList(element_type=CtyString()), ["a", "b"])
    
        result = equals(list1, list2)
        assert result.is_known
        assert result.value is True
    
        result = equals(list1, list3)
        assert result.is_known
        assert result.value is False
    
        result = equals(list1, list4)
        assert result.is_known
        assert result.value is False
    
        # Map equality
>       map1 = CtyValue(CtyMap(element_type=CtyNumber()), {"a": 1, "b": 2})
E       TypeError: CtyMap.__init__() got an unexpected keyword argument 'element_type'

tests/values/test_values_operations.py:111: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebd6d0> and <pyvider.cty.values.base.CtyValue object at 0x107ebe210>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebde50> and <pyvider.cty.values.base.CtyValue object at 0x107ebdbd0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: True
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebda90> and <pyvider.cty.values.base.CtyValue object at 0x107ebde50>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: True
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebe490> and <pyvider.cty.values.base.CtyValue object at 0x107ebda90>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: True
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebd6d0> and <pyvider.cty.values.base.CtyValue object at 0x107ebe0d0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebde50> and <pyvider.cty.values.base.CtyValue object at 0x107ebda90>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: True
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebd950> and <pyvider.cty.values.base.CtyValue object at 0x107ebde50>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: True
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebe490> and <pyvider.cty.values.base.CtyValue object at 0x107ebd950>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: False
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x107ebd6d0> and <pyvider.cty.values.base.CtyValue object at 0x107ebdf90>
_________________________________ test_length __________________________________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    @pytest.mark.asyncio
    async def test_length():
        """Test length operation."""
        # String length
        str1 = CtyValue(CtyString(), "hello")
        str2 = CtyValue(CtyString(), "")
    
        result = length(str1)
        assert result.is_known
        assert not result.is_null
        assert isinstance(result.type, CtyNumber)
        assert result.value == 5
    
        result = length(str2)
        assert result.is_known
        assert not result.is_null
        assert result.value == 0
    
        # List length
        list1 = CtyValue(CtyList(element_type=CtyString()), ["a", "b", "c"])
        list2 = CtyValue(CtyList(element_type=CtyString()), [])
    
        result = length(list1)
        assert result.is_known
        assert not result.is_null
        assert result.value == 3
    
        result = length(list2)
        assert result.is_known
        assert not result.is_null
        assert result.value == 0
    
        # Map length
>       map1 = CtyValue(CtyMap(element_type=CtyNumber()), {"a": 1, "b": 2})
E       TypeError: CtyMap.__init__() got an unexpected keyword argument 'element_type'

tests/values/test_values_operations.py:769: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting length of <pyvider.cty.values.base.CtyValue object at 0x107531590>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  String length: 5
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting length of <pyvider.cty.values.base.CtyValue object at 0x1075ed810>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  String length: 0
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting length of <pyvider.cty.values.base.CtyValue object at 0x107509260>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  list length: 3
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Getting length of <pyvider.cty.values.base.CtyValue object at 0x107509370>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  list length: 0
__________________ TestEqualsOperation.test_equals_map_values __________________
[gw22] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_more.TestEqualsOperation object at 0x12138f130>

    def test_equals_map_values(self):
        """Test equality of map values."""
        # Create map values
        map_type = CtyMap(key_type=CtyString(), value_type=CtyNumber())
        val1 = CtyValue(type_=map_type, value={"a": 1, "b": 2})
        val2 = CtyValue(type_=map_type, value={"a": 1, "b": 2})
        val3 = CtyValue(type_=map_type, value={"a": 1, "b": 3})
    
        # Compare equal maps
        result = equals(val1, val2)
>       assert result.value is True
E       assert False is True
E        +  where False = <pyvider.cty.values.base.CtyValue object at 0x1212db250>.value

tests/values/test_values_operations_more.py:117: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x121484690> and <pyvider.cty.values.base.CtyValue object at 0x1212db610>
2025-03-12 17:00:13    [ERROR]   cty.values.operations   |  Error comparing values: 'CtyMap' object has no attribute 'element_type'
________________________________ test_contains _________________________________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    @pytest.mark.asyncio
    async def test_contains():
        """Test contains operation."""
        # String containment
        str_val = CtyValue(CtyString(), "hello world")
    
        result = contains(str_val, CtyValue(CtyString(), "hello"))
        assert result.is_known
        assert not result.is_null
        assert result.value is True
    
        result = contains(str_val, CtyValue(CtyString(), "goodbye"))
        assert result.is_known
        assert not result.is_null
        assert result.value is False
    
        # List containment
        list_val = CtyValue(CtyList(element_type=CtyString()), ["a", "b", "c"])
    
        result = contains(list_val, CtyValue(CtyString(), "a"))
        assert result.is_known
        assert not result.is_null
        assert result.value is True
    
        result = contains(list_val, CtyValue(CtyString(), "d"))
        assert result.is_known
        assert not result.is_null
        assert result.value is False
    
        # Map containment (key check)
>       map_val = CtyValue(CtyMap(element_type=CtyNumber()), {"a": 1, "b": 2, "c": 3})
E       TypeError: CtyMap.__init__() got an unexpected keyword argument 'element_type'

tests/values/test_values_operations.py:854: TypeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking if <pyvider.cty.values.base.CtyValue object at 0x115784950> contains <pyvider.cty.values.base.CtyValue object at 0x115784750>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  String containment result: True
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking if <pyvider.cty.values.base.CtyValue object at 0x115784950> contains <pyvider.cty.values.base.CtyValue object at 0x1168532f0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  String containment result: False
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking if <pyvider.cty.values.base.CtyValue object at 0x1168102f0> contains <pyvider.cty.values.base.CtyValue object at 0x1157676c0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x116866150> and <pyvider.cty.values.base.CtyValue object at 0x1157676c0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: True
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking if <pyvider.cty.values.base.CtyValue object at 0x1168102f0> contains <pyvider.cty.values.base.CtyValue object at 0x116b6bee0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x11685f6b0> and <pyvider.cty.values.base.CtyValue object at 0x116b6bee0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: False
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x11686fda0> and <pyvider.cty.values.base.CtyValue object at 0x116b6bee0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: False
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Checking equality between <pyvider.cty.values.base.CtyValue object at 0x1168360d0> and <pyvider.cty.values.base.CtyValue object at 0x116b6bee0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Direct value comparison result: False
_______________________________ test_merge_maps ________________________________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

    @pytest.mark.asyncio
    async def test_merge_maps():
        """Test merge_maps operation."""
        # Basic map merging
>       map1 = CtyValue(CtyMap(element_type=CtyString()), {"a": "A", "b": "B"})
E       TypeError: CtyMap.__init__() got an unexpected keyword argument 'element_type'

tests/values/test_values_operations.py:989: TypeError
________________ TestConvertFunctions.test_can_convert_function ________________
[gw6] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x1087f10f0>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConvertFunctions object at 0x1085250f0>

    @pytest.mark.asyncio
    async def test_can_convert_function(self):
        """Test the can_convert function."""
        # Mock registry.find_conversion_path
        mock_path = [MagicMock()]
        mock_find = MagicMock(return_value=mock_path)
    
>       with patch('pyvider.cty.convert.convert.registry.find_conversion_path', mock_find):

tests/conversions/test_convert_2.py:375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x1087f10f0>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'find_conversion_path' is read-only"), <traceback object at 0x10baab540>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
_______________ TestConvertFunctions.test_unify_unsafe_function ________________
[gw7] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x104ff1350>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'unify' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConvertFunctions object at 0x104d05370>

    @pytest.mark.asyncio
    async def test_unify_unsafe_function(self):
        """Test the unify_unsafe function."""
        # Mock registry.unify
        mock_result = (CtyBool, [MagicMock(), MagicMock()])
        mock_unify = MagicMock(return_value=mock_result)
    
>       with patch('pyvider.cty.convert.convert.registry.unify', mock_unify):

tests/conversions/test_convert_2.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x104ff1350>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'unify' is read-only"), <traceback object at 0x104eb1200>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'unify' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
_________________________________ test_divide __________________________________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

a = <pyvider.cty.values.base.CtyValue object at 0x110461400>
b = <pyvider.cty.values.base.CtyValue object at 0x110489150>

    def divide(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Divide one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Result of the division
    
        Supported combinations:
        - Number / Number = Number (arithmetic division)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If dividing by zero
        """
        logger.debug(f" Dividing {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Only number division is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for division by zero
                if num_b == 0:
>                   raise ValueError("Division by zero")
E                   ValueError: Division by zero

src/pyvider/cty/values/operations.py:493: ValueError

The above exception was the direct cause of the following exception:

    @pytest.mark.asyncio
    async def test_divide():
        """Test division operation."""
        num1 = CtyValue(CtyNumber(), 84)
        num2 = CtyValue(CtyNumber(), 2)
    
        result = divide(num1, num2)
        assert result.is_known
        assert not result.is_null
        assert result.value == 42
    
        # Decimal division
        num3 = CtyValue(CtyNumber(), 1)
        num4 = CtyValue(CtyNumber(), 3)
    
        result = divide(num3, num4)
        assert result.is_known
        assert not result.is_null
        assert round(result.value, 10) == round(Decimal("0.3333333333"), 10)
    
        # Division by zero
        zero = CtyValue(CtyNumber(), 0)
    
        with pytest.raises(ValueError):
>           divide(num1, zero)

tests/values/test_values_operations.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = <pyvider.cty.values.base.CtyValue object at 0x110461400>
b = <pyvider.cty.values.base.CtyValue object at 0x110489150>

    def divide(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Divide one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Result of the division
    
        Supported combinations:
        - Number / Number = Number (arithmetic division)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If dividing by zero
        """
        logger.debug(f" Dividing {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Only number division is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for division by zero
                if num_b == 0:
                    raise ValueError("Division by zero")
    
                result = num_a / num_b
                logger.debug(f" Number division result: {result}")
                return CtyValue(CtyNumber(), result)
            except Exception as e:
                logger.error(f" Error dividing values: {e}", exc_info=True)
>               raise CtyError(f"Error dividing values: {e}") from e
E               pyvider.cty.exceptions.CtyError: Error dividing values: Division by zero

src/pyvider/cty/values/operations.py:500: CtyError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Dividing <pyvider.cty.values.base.CtyValue object at 0x110461400> by <pyvider.cty.values.base.CtyValue object at 0x1104dca50>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Number division result: 42
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Dividing <pyvider.cty.values.base.CtyValue object at 0x1104f1480> by <pyvider.cty.values.base.CtyValue object at 0x1104f15b0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Number division result: 0.3333333333333333333333333333
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Dividing <pyvider.cty.values.base.CtyValue object at 0x110461400> by <pyvider.cty.values.base.CtyValue object at 0x110489150>
2025-03-12 17:00:12    [ERROR]   cty.values.operations   |  Error dividing values: Division by zero
_________________ TestArithmeticOperations.test_negate_unknown _________________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestArithmeticOperations object at 0x1143176f0>

    def test_negate_unknown(self):
        """Test negating an unknown value."""
        val = CtyValue(type_=CtyNumber(), is_unknown=True)
        result = negate(val)
    
        assert result.type == CtyNumber()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:62: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Negating <pyvider.cty.values.base.CtyValue object at 0x1141a7140>
_________________ TestArithmeticOperations.test_divide_unknown _________________
[gw5] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestArithmeticOperations object at 0x105f29e50>

    def test_divide_unknown(self):
        """Test dividing with an unknown value."""
        val1 = CtyValue(type_=CtyNumber(), value=Decimal("42"))
        val2 = CtyValue(type_=CtyNumber(), is_unknown=True)
    
        result = divide(val1, val2)
    
        assert result.type == CtyNumber()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:116: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Dividing <pyvider.cty.values.base.CtyValue object at 0x105ca2360> by <pyvider.cty.values.base.CtyValue object at 0x105c0c050>
________________________________ test_add_lists ________________________________
[gw2] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

a = <pyvider.cty.values.base.CtyValue object at 0x1118617c0>
b = <pyvider.cty.values.base.CtyValue object at 0x111865190>

    def add(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Add two values together.
    
        Args:
            a: First value
            b: Second value
    
        Returns:
            Result of the addition
    
        Supported combinations:
        - Number + Number = Number (arithmetic addition)
        - String + String = String (concatenation)
        - list + list = list (concatenation)
    
        Raises:
            TypeError: If the operation is not supported for the given types
        """
        logger.debug(f" Adding {a} and {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            # For unknown values, return unknown of the expected result type
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                return CtyValue.unknown(CtyString())
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # For lists, ensure element types are compatible
                if a.type.element_type.equal(b.type.element_type):
                    return CtyValue.unknown(CtyList(element_type=a.type.element_type))
                else:
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
            else:
                raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            # For null values, return null of the expected result type
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                return CtyValue.null(CtyString())
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # For lists, ensure element types are compatible
                if a.type.element_type.equal(b.type.element_type):
                    return CtyValue.null(CtyList(element_type=a.type.element_type))
                else:
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
            else:
                raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
    
        # Handle actual addition
        try:
            # Number addition
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
                result = num_a + num_b
                logger.debug(f" Number addition result: {result}")
                return CtyValue(CtyNumber(), result)
    
            # String concatenation
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                result = str(a.value) + str(b.value)
                logger.debug(f" String concatenation result: {result}")
                return CtyValue(CtyString(), result)
    
            # list concatenation
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # Ensure element types are compatible
                if not a.type.element_type.equal(b.type.element_type):
>                   raise TypeMismatchError("Cannot add lists with incompatible element types")
E                   pyvider.cty.exceptions.TypeMismatchError: Cannot add lists with incompatible element types

src/pyvider/cty/values/operations.py:293: TypeMismatchError

The above exception was the direct cause of the following exception:

    @pytest.mark.asyncio
    async def test_add_lists():
        """Test list concatenation."""
        list1 = CtyValue(CtyList(element_type=CtyString()), ["a", "b"])
        list2 = CtyValue(CtyList(element_type=CtyString()), ["c", "d"])
    
        result = add(list1, list2)
        assert result.is_known
        assert not result.is_null
        assert result.value == ["a", "b", "c", "d"]
    
        # Empty lists
        list3 = CtyValue(CtyList(element_type=CtyString()), [])
    
        result = add(list1, list3)
        assert result.is_known
        assert not result.is_null
        assert result.value == ["a", "b"]
    
        result = add(list3, list3)
        assert result.is_known
        assert not result.is_null
        assert result.value == []
    
        # Incompatible element types
        list4 = CtyValue(CtyList(element_type=CtyNumber()), [1, 2])
    
        with pytest.raises(TypeMismatchError):
>           add(list1, list4)

tests/values/test_values_operations.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = <pyvider.cty.values.base.CtyValue object at 0x1118617c0>
b = <pyvider.cty.values.base.CtyValue object at 0x111865190>

    def add(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Add two values together.
    
        Args:
            a: First value
            b: Second value
    
        Returns:
            Result of the addition
    
        Supported combinations:
        - Number + Number = Number (arithmetic addition)
        - String + String = String (concatenation)
        - list + list = list (concatenation)
    
        Raises:
            TypeError: If the operation is not supported for the given types
        """
        logger.debug(f" Adding {a} and {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            # For unknown values, return unknown of the expected result type
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                return CtyValue.unknown(CtyString())
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # For lists, ensure element types are compatible
                if a.type.element_type.equal(b.type.element_type):
                    return CtyValue.unknown(CtyList(element_type=a.type.element_type))
                else:
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
            else:
                raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            # For null values, return null of the expected result type
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                return CtyValue.null(CtyString())
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # For lists, ensure element types are compatible
                if a.type.element_type.equal(b.type.element_type):
                    return CtyValue.null(CtyList(element_type=a.type.element_type))
                else:
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
            else:
                raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
    
        # Handle actual addition
        try:
            # Number addition
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
                result = num_a + num_b
                logger.debug(f" Number addition result: {result}")
                return CtyValue(CtyNumber(), result)
    
            # String concatenation
            elif isinstance(a.type, CtyString) and isinstance(b.type, CtyString):
                result = str(a.value) + str(b.value)
                logger.debug(f" String concatenation result: {result}")
                return CtyValue(CtyString(), result)
    
            # list concatenation
            elif isinstance(a.type, CtyList) and isinstance(b.type, CtyList):
                # Ensure element types are compatible
                if not a.type.element_type.equal(b.type.element_type):
                    raise TypeMismatchError("Cannot add lists with incompatible element types")
    
                a_list = cast(list[Any], a.value)
                b_list = cast(list[Any], b.value)
                result = a_list + b_list
                logger.debug(f" list concatenation result: {result}")
                return CtyValue(CtyList(element_type=a.type.element_type), result)
    
            # Unsupported combination
            else:
                raise TypeError(f"Cannot add values of types {a.type} and {b.type}")
    
        except Exception as e:
            if isinstance(e, TypeError) and "Cannot add values" in str(e):
                # Re-raise type errors from this function
                raise
    
            logger.error(f" Error adding values: {e}", exc_info=True)
>           raise CtyError(f"Error adding values: {e}") from e
E           pyvider.cty.exceptions.CtyError: Error adding values: Cannot add lists with incompatible element types

src/pyvider/cty/values/operations.py:311: CtyError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Adding <pyvider.cty.values.base.CtyValue object at 0x1118617c0> and <pyvider.cty.values.base.CtyValue object at 0x111860aa0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  list concatenation result: ['a', 'b', 'c', 'd']
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Adding <pyvider.cty.values.base.CtyValue object at 0x1118617c0> and <pyvider.cty.values.base.CtyValue object at 0x111845ef0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  list concatenation result: ['a', 'b']
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Adding <pyvider.cty.values.base.CtyValue object at 0x111845ef0> and <pyvider.cty.values.base.CtyValue object at 0x111845ef0>
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  list concatenation result: []
2025-03-12 17:00:12    [DEBUG]   cty.values.operations   |  Adding <pyvider.cty.values.base.CtyValue object at 0x1118617c0> and <pyvider.cty.values.base.CtyValue object at 0x111865190>
2025-03-12 17:00:12    [ERROR]   cty.values.operations   |  Error adding values: Cannot add lists with incompatible element types
___________ TestCollectionOperations.test_get_element_unknown_index ____________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestCollectionOperations object at 0x116b22450>

    def test_get_element_unknown_index(self):
        """Test getting an element with an unknown index."""
        list_type = CtyList(element_type=CtyString())
        list_val = CtyValue(type_=list_type, value=["a", "b", "c"])
        index = CtyValue(type_=CtyNumber(), is_unknown=True)
    
        result = get_element(list_val, index)
    
        assert result.type == CtyString()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:275: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x1168e6510> from <pyvider.cty.values.base.CtyValue object at 0x1168e63c0>
______________ TestCollectionOperations.test_get_element_unknown _______________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestCollectionOperations object at 0x106e8f790>

    def test_get_element_unknown(self):
        """Test getting an element from an unknown collection."""
        list_type = CtyList(element_type=CtyString())
        list_val = CtyValue(type_=list_type, is_unknown=True)
        index = CtyValue(type_=CtyNumber(), value=0)
    
        result = get_element(list_val, index)
    
        assert result.type == CtyString()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:255: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x106af51d0> from <pyvider.cty.values.base.CtyValue object at 0x106b5f200>
___________ TestBuiltinConversions.test_string_to_number_conversion ____________
[gw7] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <test_convert_2.TestBuiltinConversions object at 0x104c92d50>

    @pytest.mark.asyncio
    async def test_string_to_number_conversion(self):
        """Test the string to number conversion."""
        # Create string value
        string_value = CtyValue(CtyString(), "123.45")
    
        # Mock the registry and conversion
        mock_result = CtyValue(CtyNumber(), Decimal("123.45"))
        mock_converter = MagicMock()
    
        # Register a test conversion
        with patch('pyvider.cty.convert.convert.string_to_number', return_value=mock_result):
            registry.register(
                source_type=CtyString,
                target_type=CtyNumber,
                converter=mock_converter,
                is_safe=False
            )
    
            # Perform conversion
            result = await convert_unsafe(string_value, CtyNumber)
    
            # Verify result
>           assert result == mock_result
E           AssertionError: assert <MagicMock name='mock()' id='4378122560'> == <pyvider.cty.values.base.CtyValue object at 0x104f34b90>

tests/conversions/test_convert_2.py:502: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]     cty.convert.convert   |  Registering conversion from CtyString to CtyNumber (safe=False)
2025-03-12 17:00:13    [DEBUG]     cty.convert.convert   |  Converting value from CtyString to CtyNumber
2025-03-12 17:00:13    [DEBUG]     cty.convert.convert   |  Finding conversion path from CtyString to CtyNumber (unsafe=True)
2025-03-12 17:00:13    [DEBUG]     cty.convert.convert   |  Converting from CtyString to CtyNumber
2025-03-12 17:00:13    [DEBUG]     cty.convert.convert   |  Conversion successful: <MagicMock name='mock()' id='4378122560'>
_________________ TestArithmeticOperations.test_modulo_unknown _________________
[gw22] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestArithmeticOperations object at 0x12140bd40>

    def test_modulo_unknown(self):
        """Test modulo with an unknown value."""
        val1 = CtyValue(type_=CtyNumber(), value=Decimal("42"))
        val2 = CtyValue(type_=CtyNumber(), is_unknown=True)
    
        result = modulo(val1, val2)
    
        assert result.type == CtyNumber()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:171: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Calculating modulo of <pyvider.cty.values.base.CtyValue object at 0x1214879d0> by <pyvider.cty.values.base.CtyValue object at 0x1212db110>
_______________ TestCollectionOperations.test_get_element_tuple ________________
[gw17] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestCollectionOperations object at 0x10bb1f820>

    def test_get_element_tuple(self):
        """Test getting an element from a tuple."""
>       tuple_type = CtyTuple(element_types=[CtyString(), CtyNumber(), CtyBool()])
E       TypeError: CtyTuple.__init__() got an unexpected keyword argument 'element_types'

tests/values/test_values_operations_three.py:208: TypeError
___________________ TestCollectionOperations.test_merge_maps ___________________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_more.TestCollectionOperations object at 0x1059036c0>

    def test_merge_maps(self):
        """Test merging multiple maps."""
        # Create map values
        map_type = CtyMap(key_type=CtyString(), value_type=CtyString())
        val1 = CtyValue(type_=map_type, value={"a": "1", "b": "2"})
        val2 = CtyValue(type_=map_type, value={"b": "3", "c": "4"})  # b will override
    
        # Merge
>       result = merge_maps(val1, val2)

tests/values/test_values_operations_more.py:544: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

maps = (<pyvider.cty.values.base.CtyValue object at 0x1045b99d0>, <pyvider.cty.values.base.CtyValue object at 0x104530550>)
element_type = None
map_val = <pyvider.cty.values.base.CtyValue object at 0x1045b99d0>

    def merge_maps(*maps: CtyValue) -> CtyValue:
        """
        Merge multiple maps into a single map.
    
        Args:
            *maps: Map values to merge
    
        Returns:
            Merged map value
    
        Raises:
            TypeError: If any argument is not a map type
            ValueError: If maps have incompatible element types
        """
        logger.debug(f" Merging {len(maps)} maps")
    
        if not maps:
            # No maps provided - return an empty map with dynamic element type
            logger.debug(" No maps provided, returning empty map")
            return CtyValue(CtyMap(element_type=CtyDynamic()), {})
    
        # Determine the element type from the first non-null, known map
        element_type = None
        for map_val in maps:
            if not isinstance(map_val.type, CtyMap):
                raise TypeError(f"Expected map type, got {map_val.type}")
    
            if map_val.is_known and not map_val.is_null:
>               element_type = map_val.type.element_type
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:1155: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Merging 2 maps
________________ TestCollectionOperations.test_get_element_map _________________
[gw20] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

collection = <pyvider.cty.values.base.CtyValue object at 0x113cc5a90>
index = <pyvider.cty.values.base.CtyValue object at 0x113cc65d0>

    def get_element(collection: CtyValue, index: Union[CtyValue, int, str]) -> CtyValue:
        """
        Get an element from a collection.
    
        Args:
            collection: Collection value (list, map, tuple)
            index: Element index or key
    
        Returns:
            Element value
    
        Raises:
            TypeError: If collection is not a suitable type
            KeyError: If the key does not exist in a map
            IndexError: If the index is out of range for a list/tuple
        """
        logger.debug(f" Getting element at {index} from {collection}")
    
        # Convert index to CtyValue if it's not already
        if not isinstance(index, CtyValue):
            if isinstance(index, int) and (
                isinstance(collection.type, CtyList) or
                isinstance(collection.type, CtyTuple)
            ):
                index = CtyValue(CtyNumber(), index)
            elif isinstance(index, str) and isinstance(collection.type, CtyMap):
                index = CtyValue(CtyString(), index)
            else:
                raise TypeError(f"Invalid index type: {type(index).__name__}")
    
        # Handle unknown collection
        if not collection.is_known:
            # For unknown collections, return an unknown of the element type
            # (if we can determine it)
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to check if the index is a known number
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.unknown(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return unknown dynamic
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null collection
        if collection.is_null:
            # Accessing elements of null always results in null
            if isinstance(collection.type, CtyList):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to determine the element type
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.null(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return null dynamic
                return CtyValue.null(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle unknown index for known collection
        if not index.is_known:
            # For unknown indices, return an unknown of the element type
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need a known index to determine element type
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null index
        if index.is_null:
            raise ValueError("Cannot use null as an index")
    
        # Handle actual element access
        try:
            # list element access
            if isinstance(collection.type, CtyList):
                # Ensure index is a number
                if not isinstance(index.type, CtyNumber):
                    raise TypeError(f"list index must be a number, got {index.type}")
    
                # Convert index to integer
                try:
                    idx = int(index.value)
                except (ValueError, TypeError):
                    raise TypeError(f"list index must be an integer, got {index.value}")
    
                # Get the list value
                list_value = cast(list[Any], collection.value)
    
                # Check bounds
                if idx < 0 or idx >= len(list_value):
                    raise IndexError(f"list index {idx} out of range (0-{len(list_value)-1})")
    
                # Get the element
                element = list_value[idx]
                logger.debug(f" Got list element: {element}")
                return CtyValue(collection.type.element_type, element)
    
            # Map element access
            elif isinstance(collection.type, CtyMap):
                # Ensure index is a string
                if not isinstance(index.type, CtyString):
                    raise TypeError(f"Map key must be a string, got {index.type}")
    
                # Get the key
                key = str(index.value)
    
                # Get the map value
                map_value = cast(dict[str, Any], collection.value)
    
                # Check if key exists
                if key not in map_value:
                    raise KeyError(f"Map does not contain key '{key}'")
    
                # Get the element
                element = map_value[key]
                logger.debug(f" Got map element: {element}")
>               return CtyValue(collection.type.element_type, element)
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:835: AttributeError

The above exception was the direct cause of the following exception:

self = <values.test_values_operations_more.TestCollectionOperations object at 0x113e8f490>

    def test_get_element_map(self):
        """Test getting an element from a map."""
        # Create map value
        map_type = CtyMap(key_type=CtyString(), value_type=CtyNumber())
        map_value = CtyValue(type_=map_type, value={"a": 1, "b": 2})
    
        # Create key
        key = CtyValue(type_=CtyString(), value="b")
    
        # Get element
>       result = get_element(map_value, key)

tests/values/test_values_operations_more.py:405: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

collection = <pyvider.cty.values.base.CtyValue object at 0x113cc5a90>
index = <pyvider.cty.values.base.CtyValue object at 0x113cc65d0>

    def get_element(collection: CtyValue, index: Union[CtyValue, int, str]) -> CtyValue:
        """
        Get an element from a collection.
    
        Args:
            collection: Collection value (list, map, tuple)
            index: Element index or key
    
        Returns:
            Element value
    
        Raises:
            TypeError: If collection is not a suitable type
            KeyError: If the key does not exist in a map
            IndexError: If the index is out of range for a list/tuple
        """
        logger.debug(f" Getting element at {index} from {collection}")
    
        # Convert index to CtyValue if it's not already
        if not isinstance(index, CtyValue):
            if isinstance(index, int) and (
                isinstance(collection.type, CtyList) or
                isinstance(collection.type, CtyTuple)
            ):
                index = CtyValue(CtyNumber(), index)
            elif isinstance(index, str) and isinstance(collection.type, CtyMap):
                index = CtyValue(CtyString(), index)
            else:
                raise TypeError(f"Invalid index type: {type(index).__name__}")
    
        # Handle unknown collection
        if not collection.is_known:
            # For unknown collections, return an unknown of the element type
            # (if we can determine it)
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to check if the index is a known number
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.unknown(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return unknown dynamic
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null collection
        if collection.is_null:
            # Accessing elements of null always results in null
            if isinstance(collection.type, CtyList):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to determine the element type
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.null(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return null dynamic
                return CtyValue.null(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle unknown index for known collection
        if not index.is_known:
            # For unknown indices, return an unknown of the element type
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need a known index to determine element type
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null index
        if index.is_null:
            raise ValueError("Cannot use null as an index")
    
        # Handle actual element access
        try:
            # list element access
            if isinstance(collection.type, CtyList):
                # Ensure index is a number
                if not isinstance(index.type, CtyNumber):
                    raise TypeError(f"list index must be a number, got {index.type}")
    
                # Convert index to integer
                try:
                    idx = int(index.value)
                except (ValueError, TypeError):
                    raise TypeError(f"list index must be an integer, got {index.value}")
    
                # Get the list value
                list_value = cast(list[Any], collection.value)
    
                # Check bounds
                if idx < 0 or idx >= len(list_value):
                    raise IndexError(f"list index {idx} out of range (0-{len(list_value)-1})")
    
                # Get the element
                element = list_value[idx]
                logger.debug(f" Got list element: {element}")
                return CtyValue(collection.type.element_type, element)
    
            # Map element access
            elif isinstance(collection.type, CtyMap):
                # Ensure index is a string
                if not isinstance(index.type, CtyString):
                    raise TypeError(f"Map key must be a string, got {index.type}")
    
                # Get the key
                key = str(index.value)
    
                # Get the map value
                map_value = cast(dict[str, Any], collection.value)
    
                # Check if key exists
                if key not in map_value:
                    raise KeyError(f"Map does not contain key '{key}'")
    
                # Get the element
                element = map_value[key]
                logger.debug(f" Got map element: {element}")
                return CtyValue(collection.type.element_type, element)
    
            # tuple element access
            elif isinstance(collection.type, CtyTuple):
                # Ensure index is a number
                if not isinstance(index.type, CtyNumber):
                    raise TypeError(f"tuple index must be a number, got {index.type}")
    
                # Convert index to integer
                try:
                    idx = int(index.value)
                except (ValueError, TypeError):
                    raise TypeError(f"tuple index must be an integer, got {index.value}")
    
                # Get the tuple value
                tuple_value = collection.value
    
                # Check bounds
                if idx < 0 or idx >= len(tuple_value):
                    raise IndexError(f"tuple index {idx} out of range (0-{len(tuple_value)-1})")
    
                # Get the element type and value
                element_type = collection.type.element_types[idx]
                element = tuple_value[idx]
                logger.debug(f" Got tuple element: {element}")
                return CtyValue(element_type, element)
    
            # Unsupported type
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        except Exception as e:
            if isinstance(e, (TypeError, ValueError, KeyError, IndexError)):
                # Re-raise validation errors
                raise
    
            logger.error(f" Error getting element: {e}", exc_info=True)
>           raise CtyError(f"Error getting element: {e}") from e
E           pyvider.cty.exceptions.CtyError: Error getting element: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:872: CtyError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x113cc65d0> from <pyvider.cty.values.base.CtyValue object at 0x113cc5a90>
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Got map element: 2
2025-03-12 17:00:13    [ERROR]   cty.values.operations   |  Error getting element: 'CtyMap' object has no attribute 'element_type'
__________________ TestCollectionOperations.test_length_tuple __________________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestCollectionOperations object at 0x1073181f0>

    def test_length_tuple(self):
        """Test getting the length of a tuple."""
>       tuple_type = CtyTuple(element_types=[CtyString(), CtyNumber(), CtyBool()])
E       TypeError: CtyTuple.__init__() got an unexpected keyword argument 'element_types'

tests/values/test_values_operations_three.py:318: TypeError
_________________ TestCollectionOperations.test_length_unknown _________________
[gw4] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestCollectionOperations object at 0x1089ffa10>

    def test_length_unknown(self):
        """Test getting the length of an unknown value."""
        str_val = CtyValue(type_=CtyString(), is_unknown=True)
    
        result = length(str_val)
    
        assert result.type == CtyNumber()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:342: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Getting length of <pyvider.cty.values.base.CtyValue object at 0x107ebe350>
_________________ TestArithmeticOperations.test_divide_by_zero _________________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

a = <pyvider.cty.values.base.CtyValue object at 0x10507d710>
b = <pyvider.cty.values.base.CtyValue object at 0x10507e3c0>

    def divide(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Divide one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Result of the division
    
        Supported combinations:
        - Number / Number = Number (arithmetic division)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If dividing by zero
        """
        logger.debug(f" Dividing {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Only number division is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for division by zero
                if num_b == 0:
>                   raise ValueError("Division by zero")
E                   ValueError: Division by zero

src/pyvider/cty/values/operations.py:493: ValueError

The above exception was the direct cause of the following exception:

self = <values.test_values_operations_three.TestArithmeticOperations object at 0x103f97bd0>

    def test_divide_by_zero(self):
        """Test dividing by zero."""
        val1 = CtyValue(type_=CtyNumber(), value=Decimal("42"))
        val2 = CtyValue(type_=CtyNumber(), value=Decimal("0"))
    
        with pytest.raises(ValueError):
>           divide(val1, val2)

tests/values/test_values_operations_three.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = <pyvider.cty.values.base.CtyValue object at 0x10507d710>
b = <pyvider.cty.values.base.CtyValue object at 0x10507e3c0>

    def divide(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Divide one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Result of the division
    
        Supported combinations:
        - Number / Number = Number (arithmetic division)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If dividing by zero
        """
        logger.debug(f" Dividing {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot divide values of types {a.type} and {b.type}")
    
        # Only number division is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for division by zero
                if num_b == 0:
                    raise ValueError("Division by zero")
    
                result = num_a / num_b
                logger.debug(f" Number division result: {result}")
                return CtyValue(CtyNumber(), result)
            except Exception as e:
                logger.error(f" Error dividing values: {e}", exc_info=True)
>               raise CtyError(f"Error dividing values: {e}") from e
E               pyvider.cty.exceptions.CtyError: Error dividing values: Division by zero

src/pyvider/cty/values/operations.py:500: CtyError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Dividing <pyvider.cty.values.base.CtyValue object at 0x10507d710> by <pyvider.cty.values.base.CtyValue object at 0x10507e3c0>
2025-03-12 17:00:13    [ERROR]   cty.values.operations   |  Error dividing values: Division by zero
_________________ TestArithmeticOperations.test_modulo_by_zero _________________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

a = <pyvider.cty.values.base.CtyValue object at 0x1051c0950>
b = <pyvider.cty.values.base.CtyValue object at 0x105136f30>

    def modulo(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Calculate the modulo of one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Remainder of the division
    
        Supported combinations:
        - Number % Number = Number (arithmetic modulo)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If divisor is zero
        """
        logger.debug(f" Calculating modulo of {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Only number modulo is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for modulo by zero
                if num_b == 0:
>                   raise ValueError("Modulo by zero")
E                   ValueError: Modulo by zero

src/pyvider/cty/values/operations.py:547: ValueError

The above exception was the direct cause of the following exception:

self = <values.test_values_operations_three.TestArithmeticOperations object at 0x105496270>

    def test_modulo_by_zero(self):
        """Test modulo by zero."""
        val1 = CtyValue(type_=CtyNumber(), value=Decimal("42"))
        val2 = CtyValue(type_=CtyNumber(), value=Decimal("0"))
    
        with pytest.raises(ValueError):
>           modulo(val1, val2)

tests/values/test_values_operations_three.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = <pyvider.cty.values.base.CtyValue object at 0x1051c0950>
b = <pyvider.cty.values.base.CtyValue object at 0x105136f30>

    def modulo(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Calculate the modulo of one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Remainder of the division
    
        Supported combinations:
        - Number % Number = Number (arithmetic modulo)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If divisor is zero
        """
        logger.debug(f" Calculating modulo of {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Only number modulo is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for modulo by zero
                if num_b == 0:
                    raise ValueError("Modulo by zero")
    
                result = num_a % num_b
                logger.debug(f" Number modulo result: {result}")
                return CtyValue(CtyNumber(), result)
            except Exception as e:
                logger.error(f" Error calculating modulo: {e}", exc_info=True)
>               raise CtyError(f"Error calculating modulo: {e}") from e
E               pyvider.cty.exceptions.CtyError: Error calculating modulo: Modulo by zero

src/pyvider/cty/values/operations.py:554: CtyError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Calculating modulo of <pyvider.cty.values.base.CtyValue object at 0x1051c0950> by <pyvider.cty.values.base.CtyValue object at 0x105136f30>
2025-03-12 17:00:13    [ERROR]   cty.values.operations   |  Error calculating modulo: Modulo by zero
___________ TestObjectAttributeOperations.test_get_attribute_unknown ___________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestObjectAttributeOperations object at 0x1110bfce0>

    def test_get_attribute_unknown(self):
        """Test getting an attribute from an unknown object."""
        obj_type = CtyObject(attribute_types={
            "name": CtyString(),
            "age": CtyNumber()
        })
        obj_val = CtyValue(type_=obj_type, is_unknown=True)
    
        # Attribute of unknown object is unknown
        result = get_attribute(obj_val, "name")
    
        assert result.type == CtyString()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:547: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG] types.structural.object   |  Validating CtyObject configuration on initialization
2025-03-12 17:00:13    [DEBUG] types.structural.object   |  CtyObject configuration validated successfully
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Getting attribute 'name' from <pyvider.cty.values.base.CtyValue object at 0x111206bd0>
______________ TestSliceOperations.test_slice_string_null_unknown ______________
[gw5] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestSliceOperations object at 0x105c003e0>

    def test_slice_string_null_unknown(self):
        """Test slicing with null and unknown values."""
        str_val = CtyValue(type_=CtyString(), value="hello")
        start = CtyValue(type_=CtyNumber(), value=0)
        end_null = CtyValue(type_=CtyNumber(), is_null=True)
        end_unknown = CtyValue(type_=CtyNumber(), is_unknown=True)
    
        # Null index
        result = slice_string(str_val, start, end_null)
    
        assert result.type == CtyString()
        assert result.is_null is True
    
        # Unknown index
        result = slice_string(str_val, start, end_unknown)
    
        assert result.type == CtyString()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:789: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Slicing string <pyvider.cty.values.base.CtyValue object at 0x105c65e50> from <pyvider.cty.values.base.CtyValue object at 0x105c65d60> to <pyvider.cty.values.base.CtyValue object at 0x105c65f40>
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Slicing string <pyvider.cty.values.base.CtyValue object at 0x105c65e50> from <pyvider.cty.values.base.CtyValue object at 0x105c65d60> to <pyvider.cty.values.base.CtyValue object at 0x105c66030>
_________________ TestValueRefinements.test_refinement_builder _________________
[gw7] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement.TestValueRefinements object at 0x104fa3770>

    @pytest.mark.asyncio
    async def test_refinement_builder(self):
        """Test the ValueRefinementBuilder."""
        # Test building string refinements
>       builder = ValueRefinementBuilder()
E       TypeError: ValueRefinementBuilder.__init__() missing 1 required positional argument: 'value'

tests/values/test_values_refinement.py:196: TypeError
_________ TestConcatAndMergeOperations.test_concat_lists_null_unknown __________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestConcatAndMergeOperations object at 0x10509c180>

    def test_concat_lists_null_unknown(self):
        """Test concatenating with null and unknown lists."""
        list_type = CtyList(element_type=CtyString())
        list1 = CtyValue(type_=list_type, value=["a", "b"])
        list_null = CtyValue(type_=list_type, is_null=True)
        list_unknown = CtyValue(type_=list_type, is_unknown=True)
    
        # Null lists are ignored
        result = concat_lists(list1, list_null)
    
        assert result.type == list_type
        assert result.value == ["a", "b"]
    
        # Unknown lists make the result unknown
        result = concat_lists(list1, list_unknown)
    
        assert result.type == list_type
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:632: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Concatenating 2 lists
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Concatenated list result length: 2
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Concatenating 2 lists
________________ TestValueRefinement.test_multiple_refinements _________________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x1107f08a0>

    def test_multiple_refinements(self):
        """Test creating multiple refinements."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.not_null()
        builder.number_range_inclusive(10, 50)
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x111ad4d70>.is_known

tests/values/test_values_refinement_2.py:70: AssertionError
______________ TestValueRefinement.test_refinement_of_known_value ______________
[gw13] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x106ba05a0>

    def test_refinement_of_known_value(self):
        """Test refining a known value returns the same value."""
        val = CtyValue(type_=CtyString(), value="hello")
        builder = val.refine()
        builder.not_null()  # This is already satisfied
        refined = builder.new_value()
    
        # For known values, refinements still create unknown values
        # (This matches the Go implementation)
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x106b21b20>.is_known

tests/values/test_values_refinement_2.py:103: AssertionError
________________ TestCollectionOperations.test_get_element_map _________________
[gw1] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

collection = <pyvider.cty.values.base.CtyValue object at 0x107583bd0>
index = <pyvider.cty.values.base.CtyValue object at 0x1075593d0>

    def get_element(collection: CtyValue, index: Union[CtyValue, int, str]) -> CtyValue:
        """
        Get an element from a collection.
    
        Args:
            collection: Collection value (list, map, tuple)
            index: Element index or key
    
        Returns:
            Element value
    
        Raises:
            TypeError: If collection is not a suitable type
            KeyError: If the key does not exist in a map
            IndexError: If the index is out of range for a list/tuple
        """
        logger.debug(f" Getting element at {index} from {collection}")
    
        # Convert index to CtyValue if it's not already
        if not isinstance(index, CtyValue):
            if isinstance(index, int) and (
                isinstance(collection.type, CtyList) or
                isinstance(collection.type, CtyTuple)
            ):
                index = CtyValue(CtyNumber(), index)
            elif isinstance(index, str) and isinstance(collection.type, CtyMap):
                index = CtyValue(CtyString(), index)
            else:
                raise TypeError(f"Invalid index type: {type(index).__name__}")
    
        # Handle unknown collection
        if not collection.is_known:
            # For unknown collections, return an unknown of the element type
            # (if we can determine it)
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to check if the index is a known number
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.unknown(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return unknown dynamic
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null collection
        if collection.is_null:
            # Accessing elements of null always results in null
            if isinstance(collection.type, CtyList):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to determine the element type
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.null(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return null dynamic
                return CtyValue.null(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle unknown index for known collection
        if not index.is_known:
            # For unknown indices, return an unknown of the element type
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need a known index to determine element type
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null index
        if index.is_null:
            raise ValueError("Cannot use null as an index")
    
        # Handle actual element access
        try:
            # list element access
            if isinstance(collection.type, CtyList):
                # Ensure index is a number
                if not isinstance(index.type, CtyNumber):
                    raise TypeError(f"list index must be a number, got {index.type}")
    
                # Convert index to integer
                try:
                    idx = int(index.value)
                except (ValueError, TypeError):
                    raise TypeError(f"list index must be an integer, got {index.value}")
    
                # Get the list value
                list_value = cast(list[Any], collection.value)
    
                # Check bounds
                if idx < 0 or idx >= len(list_value):
                    raise IndexError(f"list index {idx} out of range (0-{len(list_value)-1})")
    
                # Get the element
                element = list_value[idx]
                logger.debug(f" Got list element: {element}")
                return CtyValue(collection.type.element_type, element)
    
            # Map element access
            elif isinstance(collection.type, CtyMap):
                # Ensure index is a string
                if not isinstance(index.type, CtyString):
                    raise TypeError(f"Map key must be a string, got {index.type}")
    
                # Get the key
                key = str(index.value)
    
                # Get the map value
                map_value = cast(dict[str, Any], collection.value)
    
                # Check if key exists
                if key not in map_value:
                    raise KeyError(f"Map does not contain key '{key}'")
    
                # Get the element
                element = map_value[key]
                logger.debug(f" Got map element: {element}")
>               return CtyValue(collection.type.element_type, element)
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:835: AttributeError

The above exception was the direct cause of the following exception:

self = <values.test_values_operations_three.TestCollectionOperations object at 0x1088960d0>

    def test_get_element_map(self):
        """Test getting an element from a map."""
        map_type = CtyMap(key_type=CtyString(), value_type=CtyNumber())
        map_val = CtyValue(type_=map_type, value={"a": 1, "b": 2})
        key = CtyValue(type_=CtyString(), value="b")
    
>       result = get_element(map_val, key)

tests/values/test_values_operations_three.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

collection = <pyvider.cty.values.base.CtyValue object at 0x107583bd0>
index = <pyvider.cty.values.base.CtyValue object at 0x1075593d0>

    def get_element(collection: CtyValue, index: Union[CtyValue, int, str]) -> CtyValue:
        """
        Get an element from a collection.
    
        Args:
            collection: Collection value (list, map, tuple)
            index: Element index or key
    
        Returns:
            Element value
    
        Raises:
            TypeError: If collection is not a suitable type
            KeyError: If the key does not exist in a map
            IndexError: If the index is out of range for a list/tuple
        """
        logger.debug(f" Getting element at {index} from {collection}")
    
        # Convert index to CtyValue if it's not already
        if not isinstance(index, CtyValue):
            if isinstance(index, int) and (
                isinstance(collection.type, CtyList) or
                isinstance(collection.type, CtyTuple)
            ):
                index = CtyValue(CtyNumber(), index)
            elif isinstance(index, str) and isinstance(collection.type, CtyMap):
                index = CtyValue(CtyString(), index)
            else:
                raise TypeError(f"Invalid index type: {type(index).__name__}")
    
        # Handle unknown collection
        if not collection.is_known:
            # For unknown collections, return an unknown of the element type
            # (if we can determine it)
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to check if the index is a known number
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.unknown(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return unknown dynamic
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null collection
        if collection.is_null:
            # Accessing elements of null always results in null
            if isinstance(collection.type, CtyList):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.null(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need to determine the element type
                if isinstance(index.type, CtyNumber) and index.is_known:
                    try:
                        idx = int(index.value)
                        if 0 <= idx < len(collection.type.element_types):
                            return CtyValue.null(collection.type.element_types[idx])
                    except (ValueError, TypeError):
                        pass
                # If we can't determine the element type, return null dynamic
                return CtyValue.null(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle unknown index for known collection
        if not index.is_known:
            # For unknown indices, return an unknown of the element type
            if isinstance(collection.type, CtyList):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyMap):
                return CtyValue.unknown(collection.type.element_type)
            elif isinstance(collection.type, CtyTuple):
                # For tuples, we need a known index to determine element type
                return CtyValue.unknown(CtyDynamic())
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        # Handle null index
        if index.is_null:
            raise ValueError("Cannot use null as an index")
    
        # Handle actual element access
        try:
            # list element access
            if isinstance(collection.type, CtyList):
                # Ensure index is a number
                if not isinstance(index.type, CtyNumber):
                    raise TypeError(f"list index must be a number, got {index.type}")
    
                # Convert index to integer
                try:
                    idx = int(index.value)
                except (ValueError, TypeError):
                    raise TypeError(f"list index must be an integer, got {index.value}")
    
                # Get the list value
                list_value = cast(list[Any], collection.value)
    
                # Check bounds
                if idx < 0 or idx >= len(list_value):
                    raise IndexError(f"list index {idx} out of range (0-{len(list_value)-1})")
    
                # Get the element
                element = list_value[idx]
                logger.debug(f" Got list element: {element}")
                return CtyValue(collection.type.element_type, element)
    
            # Map element access
            elif isinstance(collection.type, CtyMap):
                # Ensure index is a string
                if not isinstance(index.type, CtyString):
                    raise TypeError(f"Map key must be a string, got {index.type}")
    
                # Get the key
                key = str(index.value)
    
                # Get the map value
                map_value = cast(dict[str, Any], collection.value)
    
                # Check if key exists
                if key not in map_value:
                    raise KeyError(f"Map does not contain key '{key}'")
    
                # Get the element
                element = map_value[key]
                logger.debug(f" Got map element: {element}")
                return CtyValue(collection.type.element_type, element)
    
            # tuple element access
            elif isinstance(collection.type, CtyTuple):
                # Ensure index is a number
                if not isinstance(index.type, CtyNumber):
                    raise TypeError(f"tuple index must be a number, got {index.type}")
    
                # Convert index to integer
                try:
                    idx = int(index.value)
                except (ValueError, TypeError):
                    raise TypeError(f"tuple index must be an integer, got {index.value}")
    
                # Get the tuple value
                tuple_value = collection.value
    
                # Check bounds
                if idx < 0 or idx >= len(tuple_value):
                    raise IndexError(f"tuple index {idx} out of range (0-{len(tuple_value)-1})")
    
                # Get the element type and value
                element_type = collection.type.element_types[idx]
                element = tuple_value[idx]
                logger.debug(f" Got tuple element: {element}")
                return CtyValue(element_type, element)
    
            # Unsupported type
            else:
                raise TypeError(f"Cannot get element from type {collection.type}")
    
        except Exception as e:
            if isinstance(e, (TypeError, ValueError, KeyError, IndexError)):
                # Re-raise validation errors
                raise
    
            logger.error(f" Error getting element: {e}", exc_info=True)
>           raise CtyError(f"Error getting element: {e}") from e
E           pyvider.cty.exceptions.CtyError: Error getting element: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:872: CtyError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Getting element at <pyvider.cty.values.base.CtyValue object at 0x1075593d0> from <pyvider.cty.values.base.CtyValue object at 0x107583bd0>
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Got map element: 2
2025-03-12 17:00:13    [ERROR]   cty.values.operations   |  Error getting element: 'CtyMap' object has no attribute 'element_type'
______________ TestValueRefinement.test_refinement_of_null_value _______________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x1168986b0>

    def test_refinement_of_null_value(self):
        """Test refining a null value."""
        val = CtyValue(type_=CtyString(), is_null=True)
        builder = val.refine()
        builder.not_null()  # This conflicts with null
>       refined = builder.new_value()

tests/values/test_values_refinement_2.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyvider.cty.values.refinement.ValueRefinementBuilder object at 0x11684d400>

    def new_value(self) -> CtyValue:
        """Create the refined value."""
        # If value is already known, check if it satisfies refinements
        if self._value.is_known and not self._value.is_null:
            # Check each refinement
            # for refinement in self._refinements:
            #     # Validation logic based on refinement type
            #     # ...
    
            # # If all refinements are satisfied, return the original value with marks
            return self._value
    
        # For unknown values, create a new unknown with refinements
>       return CtyValue(
            type_=self._value.type,
            is_unknown=True,
            marks=self._value._marks,
            refinements=self._refinements
        )
E       TypeError: CtyValue.__init__() got an unexpected keyword argument 'refinements'

src/pyvider/cty/values/refinement.py:89: TypeError
____________ TestValueRefinement.test_number_range_with_null_bounds ____________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x105927050>

    def test_number_range_with_null_bounds(self):
        """Test number range refinement with null bounds."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(None, None)  # No bounds
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x10457a0b0>.is_known

tests/values/test_values_refinement_2.py:138: AssertionError
_____________ TestValueRefinement.test_refinement_of_unknown_value _____________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x10332ef50>

    def test_refinement_of_unknown_value(self):
        """Test refining an unknown value."""
        val = CtyValue(type_=CtyString(), is_unknown=True)
        builder = val.refine()
        builder.not_null()
>       refined = builder.new_value()

tests/values/test_values_refinement_2.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyvider.cty.values.refinement.ValueRefinementBuilder object at 0x10304d6a0>

    def new_value(self) -> CtyValue:
        """Create the refined value."""
        # If value is already known, check if it satisfies refinements
        if self._value.is_known and not self._value.is_null:
            # Check each refinement
            # for refinement in self._refinements:
            #     # Validation logic based on refinement type
            #     # ...
    
            # # If all refinements are satisfied, return the original value with marks
            return self._value
    
        # For unknown values, create a new unknown with refinements
>       return CtyValue(
            type_=self._value.type,
            is_unknown=True,
            marks=self._value._marks,
            refinements=self._refinements
        )
E       TypeError: CtyValue.__init__() got an unexpected keyword argument 'refinements'

src/pyvider/cty/values/refinement.py:89: TypeError
_________________ TestContainsOperation.test_contains_unknown __________________
[gw22] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestContainsOperation object at 0x12138f9b0>

    def test_contains_unknown(self):
        """Test contains with unknown values."""
        str_val = CtyValue(type_=CtyString(), value="hello world")
        sub_val = CtyValue(type_=CtyString(), is_unknown=True)
    
        result = contains(str_val, sub_val)
    
        assert result.type == CtyBool()
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:467: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Checking if <pyvider.cty.values.base.CtyValue object at 0x121484550> contains <pyvider.cty.values.base.CtyValue object at 0x121144910>
____________ TestValueRefinements.test_integration_with_operations _____________
[gw5] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement.TestValueRefinements object at 0x105ca0490>

    @pytest.mark.asyncio
    async def test_integration_with_operations(self):
        """Test that refinements work with value operations."""
        # Create refined values
>       string_builder = ValueRefinementBuilder()
E       TypeError: ValueRefinementBuilder.__init__() missing 1 required positional argument: 'value'

tests/values/test_values_refinement.py:248: TypeError
______________ TestConcatAndMergeOperations.test_merge_maps_empty ______________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestConcatAndMergeOperations object at 0x114397df0>

    def test_merge_maps_empty(self):
        """Test merging with empty maps."""
        map_type = CtyMap(key_type=CtyString(), value_type=CtyString())
        map1 = CtyValue(type_=map_type, value={"a": "A", "b": "B"})
        map2 = CtyValue(type_=map_type, value={})
        map3 = CtyValue(type_=map_type, value={"e": "E", "f": "F"})
    
>       result = merge_maps(map1, map2, map3)

tests/values/test_values_operations_three.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

maps = (<pyvider.cty.values.base.CtyValue object at 0x1141cb050>, <pyvider.cty.values.base.CtyValue object at 0x1141cb7d0>, <pyvider.cty.values.base.CtyValue object at 0x1141cabd0>)
element_type = None
map_val = <pyvider.cty.values.base.CtyValue object at 0x1141cb050>

    def merge_maps(*maps: CtyValue) -> CtyValue:
        """
        Merge multiple maps into a single map.
    
        Args:
            *maps: Map values to merge
    
        Returns:
            Merged map value
    
        Raises:
            TypeError: If any argument is not a map type
            ValueError: If maps have incompatible element types
        """
        logger.debug(f" Merging {len(maps)} maps")
    
        if not maps:
            # No maps provided - return an empty map with dynamic element type
            logger.debug(" No maps provided, returning empty map")
            return CtyValue(CtyMap(element_type=CtyDynamic()), {})
    
        # Determine the element type from the first non-null, known map
        element_type = None
        for map_val in maps:
            if not isinstance(map_val.type, CtyMap):
                raise TypeError(f"Expected map type, got {map_val.type}")
    
            if map_val.is_known and not map_val.is_null:
>               element_type = map_val.type.element_type
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:1155: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Merging 3 maps
_____________ TestValueRefinement.test_number_range_with_only_max ______________
[gw7] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x105a63a70>

    def test_number_range_with_only_max(self):
        """Test number range refinement with only max bound."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(None, 50)  # Only max
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x104f9bac0>.is_known

tests/values/test_values_refinement_2.py:166: AssertionError
__________ TestConcatAndMergeOperations.test_merge_maps_type_mismatch __________
[gw19] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestConcatAndMergeOperations object at 0x10d376650>

    def test_merge_maps_type_mismatch(self):
        """Test merging maps with type mismatch."""
        map_str_type = CtyMap(key_type=CtyString(), value_type=CtyString())
        map_num_type = CtyMap(key_type=CtyString(), value_type=CtyNumber())
    
        map1 = CtyValue(type_=map_str_type, value={"a": "A", "b": "B"})
        map2 = CtyValue(type_=map_num_type, value={"c": 1, "d": 2})
    
        with pytest.raises(ValueError):
>           merge_maps(map1, map2)

tests/values/test_values_operations_three.py:692: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

maps = (<pyvider.cty.values.base.CtyValue object at 0x10d095a90>, <pyvider.cty.values.base.CtyValue object at 0x10d095590>)
element_type = None
map_val = <pyvider.cty.values.base.CtyValue object at 0x10d095a90>

    def merge_maps(*maps: CtyValue) -> CtyValue:
        """
        Merge multiple maps into a single map.
    
        Args:
            *maps: Map values to merge
    
        Returns:
            Merged map value
    
        Raises:
            TypeError: If any argument is not a map type
            ValueError: If maps have incompatible element types
        """
        logger.debug(f" Merging {len(maps)} maps")
    
        if not maps:
            # No maps provided - return an empty map with dynamic element type
            logger.debug(" No maps provided, returning empty map")
            return CtyValue(CtyMap(element_type=CtyDynamic()), {})
    
        # Determine the element type from the first non-null, known map
        element_type = None
        for map_val in maps:
            if not isinstance(map_val.type, CtyMap):
                raise TypeError(f"Expected map type, got {map_val.type}")
    
            if map_val.is_known and not map_val.is_null:
>               element_type = map_val.type.element_type
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:1155: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Merging 2 maps
___________ TestConcatAndMergeOperations.test_merge_maps_overlapping ___________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestConcatAndMergeOperations object at 0x126f97ce0>

    def test_merge_maps_overlapping(self):
        """Test merging maps with overlapping keys."""
        map_type = CtyMap(key_type=CtyString(), value_type=CtyString())
        map1 = CtyValue(type_=map_type, value={"a": "A", "b": "B"})
        map2 = CtyValue(type_=map_type, value={"b": "B2", "c": "C"})
    
>       result = merge_maps(map1, map2)

tests/values/test_values_operations_three.py:660: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

maps = (<pyvider.cty.values.base.CtyValue object at 0x126d706e0>, <pyvider.cty.values.base.CtyValue object at 0x12787d860>)
element_type = None
map_val = <pyvider.cty.values.base.CtyValue object at 0x126d706e0>

    def merge_maps(*maps: CtyValue) -> CtyValue:
        """
        Merge multiple maps into a single map.
    
        Args:
            *maps: Map values to merge
    
        Returns:
            Merged map value
    
        Raises:
            TypeError: If any argument is not a map type
            ValueError: If maps have incompatible element types
        """
        logger.debug(f" Merging {len(maps)} maps")
    
        if not maps:
            # No maps provided - return an empty map with dynamic element type
            logger.debug(" No maps provided, returning empty map")
            return CtyValue(CtyMap(element_type=CtyDynamic()), {})
    
        # Determine the element type from the first non-null, known map
        element_type = None
        for map_val in maps:
            if not isinstance(map_val.type, CtyMap):
                raise TypeError(f"Expected map type, got {map_val.type}")
    
            if map_val.is_known and not map_val.is_null:
>               element_type = map_val.type.element_type
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:1155: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Merging 2 maps
______________ TestValueRefinement.test_refinement_of_known_value ______________
[gw12] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x103db87c0>

    def test_refinement_of_known_value(self):
        """Test refining a known value returns the same value."""
        val = CtyValue(type_=CtyString(), value="hello")
        builder = val.refine()
        builder.not_null()  # This is already satisfied
        refined = builder.new_value()
    
        # For known values, refinements still create unknown values
        # (This matches the Go implementation)
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x103d68360>.is_known

tests/values/test_values_refinement_3.py:100: AssertionError
_________________________________ test_modulo __________________________________
[gw10] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

a = <pyvider.cty.values.base.CtyValue object at 0x11048a030>
b = <pyvider.cty.values.base.CtyValue object at 0x11045aa50>

    def modulo(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Calculate the modulo of one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Remainder of the division
    
        Supported combinations:
        - Number % Number = Number (arithmetic modulo)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If divisor is zero
        """
        logger.debug(f" Calculating modulo of {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Only number modulo is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for modulo by zero
                if num_b == 0:
>                   raise ValueError("Modulo by zero")
E                   ValueError: Modulo by zero

src/pyvider/cty/values/operations.py:547: ValueError

The above exception was the direct cause of the following exception:

    @pytest.mark.asyncio
    async def test_modulo():
        """Test modulo operation."""
        num1 = CtyValue(CtyNumber(), 43)
        num2 = CtyValue(CtyNumber(), 10)
    
        result = modulo(num1, num2)
        assert result.is_known
        assert not result.is_null
        assert result.value == 3
    
        # Decimal modulo
        num3 = CtyValue(CtyNumber(), Decimal("10.5"))
        num4 = CtyValue(CtyNumber(), Decimal("2.5"))
    
        result = modulo(num3, num4)
        assert result.is_known
        assert not result.is_null
        assert result.value == Decimal("0.5")
    
        # Modulo by zero
        zero = CtyValue(CtyNumber(), 0)
    
        with pytest.raises(ValueError):
>           modulo(num1, zero)

tests/values/test_values_operations.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = <pyvider.cty.values.base.CtyValue object at 0x11048a030>
b = <pyvider.cty.values.base.CtyValue object at 0x11045aa50>

    def modulo(a: CtyValue, b: CtyValue) -> CtyValue:
        """
        Calculate the modulo of one value by another.
    
        Args:
            a: Dividend
            b: Divisor
    
        Returns:
            Remainder of the division
    
        Supported combinations:
        - Number % Number = Number (arithmetic modulo)
    
        Raises:
            TypeError: If the operation is not supported for the given types
            ValueError: If divisor is zero
        """
        logger.debug(f" Calculating modulo of {a} by {b}")
    
        # Handle unknown values
        if not a.is_known or not b.is_known:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.unknown(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Handle null values
        if a.is_null or b.is_null:
            if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
                return CtyValue.null(CtyNumber())
            else:
                raise TypeError(f"Cannot calculate modulo of values of types {a.type} and {b.type}")
    
        # Only number modulo is supported
        if isinstance(a.type, CtyNumber) and isinstance(b.type, CtyNumber):
            try:
                num_a = Decimal(str(a.value))
                num_b = Decimal(str(b.value))
    
                # Check for modulo by zero
                if num_b == 0:
                    raise ValueError("Modulo by zero")
    
                result = num_a % num_b
                logger.debug(f" Number modulo result: {result}")
                return CtyValue(CtyNumber(), result)
            except Exception as e:
                logger.error(f" Error calculating modulo: {e}", exc_info=True)
>               raise CtyError(f"Error calculating modulo: {e}") from e
E               pyvider.cty.exceptions.CtyError: Error calculating modulo: Modulo by zero

src/pyvider/cty/values/operations.py:554: CtyError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Calculating modulo of <pyvider.cty.values.base.CtyValue object at 0x11048a030> by <pyvider.cty.values.base.CtyValue object at 0x110421850>
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Number modulo result: 3
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Calculating modulo of <pyvider.cty.values.base.CtyValue object at 0x110467020> by <pyvider.cty.values.base.CtyValue object at 0x110467110>
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Number modulo result: 0.5
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Calculating modulo of <pyvider.cty.values.base.CtyValue object at 0x11048a030> by <pyvider.cty.values.base.CtyValue object at 0x11045aa50>
2025-03-12 17:00:13    [ERROR]   cty.values.operations   |  Error calculating modulo: Modulo by zero
____________ TestValueRefinement.test_number_range_with_null_bounds ____________
[gw20] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x114863f20>

    def test_number_range_with_null_bounds(self):
        """Test number range refinement with null bounds."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(None, None)  # No bounds
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x113a0a350>.is_known

tests/values/test_values_refinement_3.py:148: AssertionError
__________ TestConcatAndMergeOperations.test_merge_maps_null_unknown ___________
[gw18] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestConcatAndMergeOperations object at 0x113c2e750>

    def test_merge_maps_null_unknown(self):
        """Test merging with null and unknown maps."""
        map_type = CtyMap(key_type=CtyString(), value_type=CtyString())
        map1 = CtyValue(type_=map_type, value={"a": "A", "b": "B"})
        map_null = CtyValue(type_=map_type, is_null=True)
        map_unknown = CtyValue(type_=map_type, is_unknown=True)
    
        # Null maps are ignored
>       result = merge_maps(map1, map_null)

tests/values/test_values_operations_three.py:702: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

maps = (<pyvider.cty.values.base.CtyValue object at 0x1139f2520>, <pyvider.cty.values.base.CtyValue object at 0x1139f2780>)
element_type = None
map_val = <pyvider.cty.values.base.CtyValue object at 0x1139f2520>

    def merge_maps(*maps: CtyValue) -> CtyValue:
        """
        Merge multiple maps into a single map.
    
        Args:
            *maps: Map values to merge
    
        Returns:
            Merged map value
    
        Raises:
            TypeError: If any argument is not a map type
            ValueError: If maps have incompatible element types
        """
        logger.debug(f" Merging {len(maps)} maps")
    
        if not maps:
            # No maps provided - return an empty map with dynamic element type
            logger.debug(" No maps provided, returning empty map")
            return CtyValue(CtyMap(element_type=CtyDynamic()), {})
    
        # Determine the element type from the first non-null, known map
        element_type = None
        for map_val in maps:
            if not isinstance(map_val.type, CtyMap):
                raise TypeError(f"Expected map type, got {map_val.type}")
    
            if map_val.is_known and not map_val.is_null:
>               element_type = map_val.type.element_type
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:1155: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Merging 2 maps
_____________ TestValueRefinement.test_refinement_of_unknown_value _____________
[gw11] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x1053fb150>

    def test_refinement_of_unknown_value(self):
        """Test refining an unknown value."""
        val = CtyValue(type_=CtyString(), is_unknown=True)
        builder = val.refine()
        builder.not_null()
>       refined = builder.new_value()

tests/values/test_values_refinement_3.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyvider.cty.values.refinement.ValueRefinementBuilder object at 0x1050fc410>

    def new_value(self) -> CtyValue:
        """Create the refined value."""
        # If value is already known, check if it satisfies refinements
        if self._value.is_known and not self._value.is_null:
            # Check each refinement
            # for refinement in self._refinements:
            #     # Validation logic based on refinement type
            #     # ...
    
            # # If all refinements are satisfied, return the original value with marks
            return self._value
    
        # For unknown values, create a new unknown with refinements
>       return CtyValue(
            type_=self._value.type,
            is_unknown=True,
            marks=self._value._marks,
            refinements=self._refinements
        )
E       TypeError: CtyValue.__init__() got an unexpected keyword argument 'refinements'

src/pyvider/cty/values/refinement.py:89: TypeError
______________ TestValueRefinement.test_string_prefix_refinement _______________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x10767b4d0>

    def test_string_prefix_refinement(self):
        """Test creating a string prefix refinement."""
        val = CtyValue(type_=CtyString(), value="hello")
        builder = val.refine()
        builder.string_prefix("he")
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x10731d350>.is_known

tests/values/test_values_refinement_3.py:37: AssertionError
_______________ TestValueRefinement.test_number_range_refinement _______________
[gw22] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x12119c770>

    def test_number_range_refinement(self):
        """Test creating a number range refinement."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(10, 50)
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x121144cd0>.is_known

tests/values/test_values_refinement_2.py:53: AssertionError
______________ TestValueRefinement.test_refinement_of_null_value _______________
[gw14] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x1045b88d0>

    def test_refinement_of_null_value(self):
        """Test refining a null value."""
        val = CtyValue(type_=CtyString(), is_null=True)
        builder = val.refine()
        builder.not_null()  # This conflicts with null
>       refined = builder.new_value()

tests/values/test_values_refinement_3.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pyvider.cty.values.refinement.ValueRefinementBuilder object at 0x10457c2d0>

    def new_value(self) -> CtyValue:
        """Create the refined value."""
        # If value is already known, check if it satisfies refinements
        if self._value.is_known and not self._value.is_null:
            # Check each refinement
            # for refinement in self._refinements:
            #     # Validation logic based on refinement type
            #     # ...
    
            # # If all refinements are satisfied, return the original value with marks
            return self._value
    
        # For unknown values, create a new unknown with refinements
>       return CtyValue(
            type_=self._value.type,
            is_unknown=True,
            marks=self._value._marks,
            refinements=self._refinements
        )
E       TypeError: CtyValue.__init__() got an unexpected keyword argument 'refinements'

src/pyvider/cty/values/refinement.py:89: TypeError
________________ TestValueRefinement.test_multiple_refinements _________________
[gw17] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x10b9f0b00>

    def test_multiple_refinements(self):
        """Test creating multiple refinements."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.not_null()
        builder.number_range_inclusive(10, 50)
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x10b96ef50>.is_known

tests/values/test_values_refinement_3.py:67: AssertionError
_________________ TestValueRefinement.test_not_null_refinement _________________
[gw21] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x116b77890>

    def test_not_null_refinement(self):
        """Test creating a not-null refinement."""
        val = CtyValue(type_=CtyString(), value="hello")
        builder = val.refine()
        builder.not_null()
        refined = builder.new_value()
    
>       assert refined.is_known is False  # Refinements create unknown values
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x1156efee0>.is_known

tests/values/test_values_refinement_3.py:25: AssertionError
__________ TestValueRefinement.test_refinement_with_negative_numbers ___________
[gw3] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x1033bf3f0>

    def test_refinement_with_negative_numbers(self):
        """Test number range refinement with negative numbers."""
        val = CtyValue(type_=CtyNumber(), value=-10)
        builder = val.refine()
        builder.number_range_inclusive(-20, -5)
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x103033af0>.is_known

tests/values/test_values_refinement_2.py:180: AssertionError
_______________ TestValueRefinement.test_number_range_refinement _______________
[gw2] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x1118f49d0>

    def test_number_range_refinement(self):
        """Test creating a number range refinement."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(10, 50)
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x1118707c0>.is_known

tests/values/test_values_refinement_3.py:50: AssertionError
_____________ TestValueRefinements.test_integration_with_encoding ______________
[gw0] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement.TestValueRefinements object at 0x1050b8380>

    @pytest.mark.asyncio
    async def test_integration_with_encoding(self):
        """Test that refinements survive encoding/decoding."""
        # Create refined values
>       string_builder = ValueRefinementBuilder()
E       TypeError: ValueRefinementBuilder.__init__() missing 1 required positional argument: 'value'

tests/values/test_values_refinement.py:333: TypeError
_____________ TestValueRefinement.test_number_range_with_only_min ______________
[gw8] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_2.TestValueRefinement object at 0x111a63980>

    def test_number_range_with_only_min(self):
        """Test number range refinement with only min bound."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(10, None)  # Only min
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x1119fb540>.is_known

tests/values/test_values_refinement_2.py:152: AssertionError
_________________ TestConvertFunctions.test_can_convert_false __________________
[gw6] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <unittest.mock._patch object at 0x109a8c710>

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
        original, local = self.get_original()
    
        if new is DEFAULT and autospec is None:
            inherit = False
            if spec is True:
                # set spec to the object we are replacing
                spec = original
                if spec_set is True:
                    spec_set = original
                    spec = None
            elif spec is not None:
                if spec_set is True:
                    spec_set = spec
                    spec = None
            elif spec_set is True:
                spec_set = original
    
            if spec is not None or spec_set is not None:
                if original is DEFAULT:
                    raise TypeError("Can't use 'spec' with create=True")
                if isinstance(original, type):
                    # If we're patching out a class and there is a spec
                    inherit = True
    
            # Determine the Klass to use
            if new_callable is not None:
                Klass = new_callable
            elif spec is None and _is_async_obj(original):
                Klass = AsyncMock
            elif spec is not None or spec_set is not None:
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if _is_list(this_spec):
                    not_callable = '__call__' not in this_spec
                else:
                    not_callable = not callable(this_spec)
                if _is_async_obj(this_spec):
                    Klass = AsyncMock
                elif not_callable:
                    Klass = NonCallableMagicMock
                else:
                    Klass = MagicMock
            else:
                Klass = MagicMock
    
            _kwargs = {}
            if spec is not None:
                _kwargs['spec'] = spec
            if spec_set is not None:
                _kwargs['spec_set'] = spec_set
    
            # add a name to mocks
            if (isinstance(Klass, type) and
                issubclass(Klass, NonCallableMock) and self.attribute):
                _kwargs['name'] = self.attribute
    
            _kwargs.update(kwargs)
            new = Klass(**_kwargs)
    
            if inherit and _is_instance_mock(new):
                # we can only tell if the instance should be callable if the
                # spec is not a list
                this_spec = spec
                if spec_set is not None:
                    this_spec = spec_set
                if (not _is_list(this_spec) and not
                    _instance_callable(this_spec)):
                    Klass = NonCallableMagicMock
    
                _kwargs.pop('name')
                new.return_value = Klass(_new_parent=new, _new_name='()',
                                         **_kwargs)
        elif autospec is not None:
            # spec is ignored, new *must* be default, spec_set is treated
            # as a boolean. Should we check spec is not None and that spec_set
            # is a bool?
            if new is not DEFAULT:
                raise TypeError(
                    "autospec creates the mock for you. Can't specify "
                    "autospec and new."
                )
            if original is DEFAULT:
                raise TypeError("Can't use 'autospec' with create=True")
            spec_set = bool(spec_set)
            if autospec is True:
                autospec = original
    
            if _is_instance_mock(self.target):
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} as the patch '
                    f'target has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
            if _is_instance_mock(autospec):
                target_name = getattr(self.target, '__name__', self.target)
                raise InvalidSpecError(
                    f'Cannot autospec attr {self.attribute!r} from target '
                    f'{target_name!r} as it has already been mocked out. '
                    f'[target={self.target!r}, attr={autospec!r}]')
    
            new = create_autospec(autospec, spec_set=spec_set,
                                  _name=self.attribute, **kwargs)
        elif kwargs:
            # can't set keyword args when we aren't creating the mock
            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
            raise TypeError("Can't pass kwargs to a mock we aren't creating")
    
        new_attr = new
    
        self.temp_original = original
        self.is_local = local
        self._exit_stack = contextlib.ExitStack()
        self.is_started = True
        try:
>           setattr(self.target, self.attribute, new_attr)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1609: AttributeError

During handling of the above exception, another exception occurred:

self = <test_convert_2.TestConvertFunctions object at 0x1085248a0>

    @pytest.mark.asyncio
    async def test_can_convert_false(self):
        """Test the can_convert function returning False."""
        # Mock registry.find_conversion_path to return None
        mock_find = MagicMock(return_value=None)
    
>       with patch('pyvider.cty.convert.convert.registry.find_conversion_path', mock_find):

tests/conversions/test_convert_2.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1622: in __enter__
    if not self.__exit__(*sys.exc_info()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x109a8c710>
exc_info = (<class 'AttributeError'>, AttributeError("'ConversionRegistry' object attribute 'find_conversion_path' is read-only"), <traceback object at 0x108655500>)

    def __exit__(self, *exc_info):
        """Undo the patch."""
        if not self.is_started:
            return
    
        if self.is_local and self.temp_original is not DEFAULT:
            setattr(self.target, self.attribute, self.temp_original)
        else:
>           delattr(self.target, self.attribute)
E           AttributeError: 'ConversionRegistry' object attribute 'find_conversion_path' is read-only

/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1633: AttributeError
_____________ TestValueRefinement.test_number_range_with_only_min ______________
[gw5] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x105c64050>

    def test_number_range_with_only_min(self):
        """Test number range refinement with only min bound."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(10, None)  # Only min
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x105c66f30>.is_known

tests/values/test_values_refinement_3.py:162: AssertionError
__________ TestValueRefinement.test_refinement_with_negative_numbers ___________
[gw7] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x104f90830>

    def test_refinement_with_negative_numbers(self):
        """Test number range refinement with negative numbers."""
        val = CtyValue(type_=CtyNumber(), value=-10)
        builder = val.refine()
        builder.number_range_inclusive(-20, -5)
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x104f05350>.is_known

tests/values/test_values_refinement_3.py:190: AssertionError
______________ TestValueRefinements.test_number_range_refinement _______________
[gw9] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement.TestValueRefinements object at 0x126df0640>

    @pytest.mark.asyncio
    async def test_number_range_refinement(self):
        """Test that NumberRangeRefinement correctly validates values."""
        refinement = NumberRangeRefinement(
            min_value=0,
            max_value=100,
            min_inclusive=True,
            max_inclusive=True
        )
    
        # Test validation
>       assert await refinement.is_valid_for(0)
E       AttributeError: 'NumberRangeRefinement' object has no attribute 'is_valid_for'

tests/values/test_values_refinement.py:110: AttributeError
_________________ TestConcatAndMergeOperations.test_merge_maps _________________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestConcatAndMergeOperations object at 0x110f38290>

    def test_merge_maps(self):
        """Test merging maps."""
        map_type = CtyMap(key_type=CtyString(), value_type=CtyString())
        map1 = CtyValue(type_=map_type, value={"a": "A", "b": "B"})
        map2 = CtyValue(type_=map_type, value={"c": "C", "d": "D"})
        map3 = CtyValue(type_=map_type, value={"e": "E", "f": "F"})
    
>       result = merge_maps(map1, map2, map3)

tests/values/test_values_operations_three.py:647: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

maps = (<pyvider.cty.values.base.CtyValue object at 0x110f9b380>, <pyvider.cty.values.base.CtyValue object at 0x110f9b4d0>, <pyvider.cty.values.base.CtyValue object at 0x110f9b460>)
element_type = None
map_val = <pyvider.cty.values.base.CtyValue object at 0x110f9b380>

    def merge_maps(*maps: CtyValue) -> CtyValue:
        """
        Merge multiple maps into a single map.
    
        Args:
            *maps: Map values to merge
    
        Returns:
            Merged map value
    
        Raises:
            TypeError: If any argument is not a map type
            ValueError: If maps have incompatible element types
        """
        logger.debug(f" Merging {len(maps)} maps")
    
        if not maps:
            # No maps provided - return an empty map with dynamic element type
            logger.debug(" No maps provided, returning empty map")
            return CtyValue(CtyMap(element_type=CtyDynamic()), {})
    
        # Determine the element type from the first non-null, known map
        element_type = None
        for map_val in maps:
            if not isinstance(map_val.type, CtyMap):
                raise TypeError(f"Expected map type, got {map_val.type}")
    
            if map_val.is_known and not map_val.is_null:
>               element_type = map_val.type.element_type
E               AttributeError: 'CtyMap' object has no attribute 'element_type'

src/pyvider/cty/values/operations.py:1155: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Merging 3 maps
_______________ TestSliceOperations.test_slice_list_null_unknown _______________
[gw16] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_operations_three.TestSliceOperations object at 0x1141b8050>

    def test_slice_list_null_unknown(self):
        """Test slicing with null and unknown values."""
        list_type = CtyList(element_type=CtyString())
        list_val = CtyValue(type_=list_type, value=["a", "b", "c"])
        start = CtyValue(type_=CtyNumber(), value=0)
        end_null = CtyValue(type_=CtyNumber(), is_null=True)
        end_unknown = CtyValue(type_=CtyNumber(), is_unknown=True)
    
        # Null index
        result = slice_list(list_val, start, end_null)
    
        assert result.type == list_type
        assert result.is_null is True
    
        # Unknown index
        result = slice_list(list_val, start, end_unknown)
    
        assert result.type == list_type
>       assert result.is_unknown is True
E       AttributeError: 'CtyValue' object has no attribute 'is_unknown'. Did you mean: 'is_known'?

tests/values/test_values_operations_three.py:892: AttributeError
----------------------------- Captured stderr call -----------------------------
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Slicing list <pyvider.cty.values.base.CtyValue object at 0x1144081d0> from <pyvider.cty.values.base.CtyValue object at 0x114408ad0> to <pyvider.cty.values.base.CtyValue object at 0x11440aed0>
2025-03-12 17:00:13    [DEBUG]   cty.values.operations   |  Slicing list <pyvider.cty.values.base.CtyValue object at 0x1144081d0> from <pyvider.cty.values.base.CtyValue object at 0x114408ad0> to <pyvider.cty.values.base.CtyValue object at 0x11418f050>
_____________ TestValueRefinement.test_number_range_with_only_max ______________
[gw15] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x10739cd70>

    def test_number_range_with_only_max(self):
        """Test number range refinement with only max bound."""
        val = CtyValue(type_=CtyNumber(), value=42)
        builder = val.refine()
        builder.number_range_inclusive(None, 50)  # Only max
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x10731d750>.is_known

tests/values/test_values_refinement_3.py:176: AssertionError
___________ TestValueRefinement.test_string_prefix_with_empty_prefix ___________
[gw23] darwin -- Python 3.13.2 /Users/tim/code/pyvider-cty/.venv/bin/python3

self = <values.test_values_refinement_3.TestValueRefinement object at 0x1111cb250>

    def test_string_prefix_with_empty_prefix(self):
        """Test string prefix refinement with empty prefix."""
        val = CtyValue(type_=CtyString(), value="hello")
        builder = val.refine()
        builder.string_prefix("")  # Empty prefix matches anything
        refined = builder.new_value()
    
>       assert refined.is_known is False
E       assert True is False
E        +  where True = <pyvider.cty.values.base.CtyValue object at 0x110e0f4d0>.is_known

tests/values/test_values_refinement_3.py:135: AssertionError
=============================== warnings summary ===============================
tests/conversions/test_convert.py::TestConversionSystem::test_invalid_conversions
  /opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/asyncio/base_events.py:2041: RuntimeWarning: coroutine 'string_to_number' was never awaited
    handle = None  # Needed to break cycles when an exception occurs.
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_no_conversion
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_unknown_value
FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_known_value
FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_with_marks
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_register_unsafe_conversion
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_unification
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_unsafe_with_unsafe_conversion
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_get_nonexistent_conversion
FAILED tests/conversions/test_convert_base.py::TestConversion::test_conversion_init
FAILED tests/conversions/test_convert_base.py::TestConversion::test_conversion_convert
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_custom_conversion
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_map
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_null_value
FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_unknown_value
FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_null_value
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_unsafe_no_conversion
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_multiple_conversions
FAILED tests/list/test_cty_collections_list.py::test_CtyList_validate_nested_lists
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_type
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_dynamic
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_marshal_unmarshal_roundtrip
FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_function_registry
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_primitive_conversions
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_invalid_conversions
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_conversion_path_finding
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_register_safe_conversion
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_tuple_as_list
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_marked_value
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_none_becomes_empty_list
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_same_type
FAILED tests/conversions/test_convert_base.py::TestConversionRegistry::test_convert_with_conversion
FAILED tests/list/test_cty_collections_list.py::test_CtyList_dynamic_schema
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_integration_with_operations
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_complex_type
FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_conversion_functions
FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_integration_with_values
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_marshal_unmarshal_roundtrip
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_decode_roundtrip_string
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_string_value
FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_parameter_validation
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_set
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_object
FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_string_to_number_invalid_string
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_negative_index
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_invalid_container
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_null_and_unknown_handling
FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_string_functions
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_null_data
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_invalid_json
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_complex_value
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_integration_with_functions
FAILED tests/conversions/test_convert_primitive.py::TestPrimitiveConversions::test_register_conversion_call
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_known_value
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_same_element_type
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_string_representation
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_string_representation_complex
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_list_equality_operator
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_invalid_container_type
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_homogeneous_list
FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_filesystem_functions
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_error_handling
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_list_value
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_map_value
FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_convert_function
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_number_value
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_bool_value
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_string_data
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_bytes_data
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_nested_lists
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_tuple
FAILED tests/conversions/test_convert.py::TestConversionSystem::test_collection_type_handling
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_non_list_type
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_same_type
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_different_type
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_equal_different_element_type
FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_unsafe_function
FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_crypto_functions
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_post_init_validates_element_type
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_repr_representation
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_tuples_invalid
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_number_value
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_null_values
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_unknown_values
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_nested_list_with_errors
FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_different_type
FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_variadic_parameter
FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_function_spec
FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_numeric_functions
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_string
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_number
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_bool
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_unknown_value
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_with_ext_hook_unknown
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_valid_index
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_complex_type
FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_valid_index
FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_null_and_unknown_handling
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_string_value
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_empty_list_elements
FAILED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_convert
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_marshal_with_type
FAILED tests/encoding/test_encoding_json.py::TestJsonEncoding::test_unmarshal_complex_data
FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_empty_list_elements
FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_lists_of_strings
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_usable_as_non_list_type
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListWithNestedTypes::test_list_of_lists_of_strings
FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_list_of_tuples
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_element_at_invalid_index
FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_usable_as_same_type
FAILED tests/list/test_cty_collections_list.py::test_CtyList_validate_success
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_list_inequality_operator
FAILED tests/object/test_cty_structural_object.py::test_ctyobject_get_valid_attribute
FAILED tests/functions/test_stdlib.py::TestStdlibFunctions::test_collection_functions
FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_nested_lists
FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_tuple_as_list
FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_validate_homogeneous_list
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_marked_values
FAILED tests/list/test_list_advanced.py::TestCtyListAdvanced::test_element_at_negative_index
FAILED tests/functions/test_function_base.py::TestFunctionSystem::test_function_callable
FAILED tests/object/test_cty_structural_object.py::test_create_object_helper
FAILED tests/list/test_cty_collections_list_improve.py::TestCtyListAdvanced::test_validate_heterogeneous_list_fails
FAILED tests/encoding/test_encoding_msgpack.py::TestCtyMsgpackIntegration::test_encode_decode_list
FAILED tests/object/test_cty_structural_object.py::test_ctyobject_nested_validation
FAILED tests/object/test_cty_structural_object.py::test_ctyobject_validate_success
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_decode_with_ext_hook_null
FAILED tests/encoding/test_encoding_msgpack_more.py::TestMsgpackEncoding::test_encode_null_value
FAILED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_success
FAILED tests/object/test_object.py::TestCtyObjectIntegration::test_complex_nested_object
FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_convert_unsafe_function
FAILED tests/object/test_object.py::TestCtyObjectIntegration::test_validation_with_optional_attributes
FAILED tests/path/test_path.py::TestPathSystem::test_key_paths - AttributeErr...
FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_unify_function
FAILED tests/object/test_cty_structural_object.py::test_ctyobject_invalid_constructor_types
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init_with_validators
FAILED tests/path/test_path.py::TestPathSystem::test_attribute_paths - Attrib...
FAILED tests/object/test_cty_structural_object.py::test_ctyobject_with_blocks
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_validate_with_validators
FAILED tests/object/test_cty_structural_object.py::test_complex_nested_object
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_usable_as
FAILED tests/list/test_list_with_nested_types.py::TestCtyListWithNestedTypes::test_complex_nesting
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init
FAILED tests/values/test_values_base.py::TestValue::test_value_add_mark - Nam...
FAILED tests/path/test_path.py::TestPathSystem::test_complex_paths - Attribut...
FAILED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_convert_no_path
FAILED tests/values/test_values_base.py::TestValue::test_value_unmark - NameE...
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_validate
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_equal
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_string_representation
FAILED tests/path/test_path.py::TestPathSystem::test_index_paths - AttributeE...
FAILED tests/types/test_cty_type.py::TestDynamicPseudoType::test_dynamic_type_init_with_metadata
FAILED tests/values/test_values_base.py::TestValue::test_value_add_multiple_marks
FAILED tests/conversions/test_convert_2.py::TestConversionRegistry::test_registry_unify
FAILED tests/path/test_path.py::TestPathSystem::test_null_and_unknown_handling
FAILED tests/values/test_values_operations.py::test_get_element - TypeError: ...
FAILED tests/values/test_values_operations.py::test_equals_complex - TypeErro...
FAILED tests/values/test_values_operations.py::test_length - TypeError: CtyMa...
FAILED tests/values/test_values_operations_more.py::TestEqualsOperation::test_equals_map_values
FAILED tests/values/test_values_operations.py::test_contains - TypeError: Cty...
FAILED tests/values/test_values_operations.py::test_merge_maps - TypeError: C...
FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_function
FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_unify_unsafe_function
FAILED tests/values/test_values_operations.py::test_divide - pyvider.cty.exce...
FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_negate_unknown
FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_unknown
FAILED tests/values/test_values_operations.py::test_add_lists - pyvider.cty.e...
FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_unknown_index
FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_unknown
FAILED tests/conversions/test_convert_2.py::TestBuiltinConversions::test_string_to_number_conversion
FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_unknown
FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_tuple
FAILED tests/values/test_values_operations_more.py::TestCollectionOperations::test_merge_maps
FAILED tests/values/test_values_operations_more.py::TestCollectionOperations::test_get_element_map
FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_tuple
FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_length_unknown
FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_divide_by_zero
FAILED tests/values/test_values_operations_three.py::TestArithmeticOperations::test_modulo_by_zero
FAILED tests/values/test_values_operations_three.py::TestObjectAttributeOperations::test_get_attribute_unknown
FAILED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_string_null_unknown
FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_refinement_builder
FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_concat_lists_null_unknown
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_multiple_refinements
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_known_value
FAILED tests/values/test_values_operations_three.py::TestCollectionOperations::test_get_element_map
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_null_value
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_null_bounds
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_of_unknown_value
FAILED tests/values/test_values_operations_three.py::TestContainsOperation::test_contains_unknown
FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_integration_with_operations
FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_empty
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_only_max
FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_type_mismatch
FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_overlapping
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_known_value
FAILED tests/values/test_values_operations.py::test_modulo - pyvider.cty.exce...
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_null_bounds
FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps_null_unknown
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_unknown_value
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_string_prefix_refinement
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_refinement
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_of_null_value
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_multiple_refinements
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_not_null_refinement
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_refinement_with_negative_numbers
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_refinement
FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_integration_with_encoding
FAILED tests/values/test_values_refinement_2.py::TestValueRefinement::test_number_range_with_only_min
FAILED tests/conversions/test_convert_2.py::TestConvertFunctions::test_can_convert_false
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_only_min
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_refinement_with_negative_numbers
FAILED tests/values/test_values_refinement.py::TestValueRefinements::test_number_range_refinement
FAILED tests/values/test_values_operations_three.py::TestConcatAndMergeOperations::test_merge_maps
FAILED tests/values/test_values_operations_three.py::TestSliceOperations::test_slice_list_null_unknown
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_number_range_with_only_max
FAILED tests/values/test_values_refinement_3.py::TestValueRefinement::test_string_prefix_with_empty_prefix
ERROR tests/collections/test_collections_map.py
ERROR tests/collections/test_collections_set.py
ERROR tests/conversions/test_conversion_registry.py
ERROR tests/conversions/test_conversion_registry_2.py
======= 214 failed, 234 passed, 7 skipped, 1 warning, 4 errors in 1.89s ========
